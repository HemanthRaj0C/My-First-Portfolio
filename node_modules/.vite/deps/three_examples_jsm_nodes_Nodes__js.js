import {
  ACESFilmicToneMapping,
  AmbientLight,
  CineonToneMapping,
  Color,
  DepthTexture,
  DirectionalLight,
  DynamicDrawUsage,
  EventDispatcher,
  FileLoader,
  Float16BufferAttribute,
  FramebufferTexture,
  HemisphereLight,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  LineBasicMaterial,
  LinearEncoding,
  LinearSRGBColorSpace,
  LinearToneMapping,
  Loader,
  Material,
  MaterialLoader,
  MathUtils,
  Matrix3,
  Matrix4,
  MeshBasicMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  NearestFilter,
  NoColorSpace,
  NoToneMapping,
  ObjectLoader,
  ObjectSpaceNormalMap,
  PointLight,
  PointsMaterial,
  REVISION,
  ReinhardToneMapping,
  SRGBColorSpace,
  ShaderMaterial,
  SpotLight,
  SpriteMaterial,
  StaticDrawUsage,
  TangentSpaceNormalMap,
  Vector2,
  Vector3,
  Vector4,
  sRGBEncoding
} from "./chunk-KRTSOPLI.js";
import {
  __export
} from "./chunk-4EOJPDL2.js";

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
var NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
var NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
};
var defaultShaderStages = ["fragment", "vertex"];
var defaultBuildStages = ["construct", "analyze", "generate"];
var shaderStages = [...defaultShaderStages, "compute"];
var vectorComponents = ["x", "y", "z", "w"];

// node_modules/three/examples/jsm/nodes/core/NodeUtils.js
var NodeUtils_exports = {};
__export(NodeUtils_exports, {
  arrayBufferToBase64: () => arrayBufferToBase64,
  base64ToArrayBuffer: () => base64ToArrayBuffer,
  getCacheKey: () => getCacheKey,
  getNodeChildren: () => getNodeChildren,
  getValueFromType: () => getValueFromType,
  getValueType: () => getValueType
});
function getCacheKey(object) {
  let cacheKey = "{";
  if (object.isNode === true) {
    cacheKey += `uuid:"${object.uuid}"`;
  }
  for (const { property: property2, index, childNode } of getNodeChildren(object)) {
    let childCacheKey = getCacheKey(childNode);
    if (!childCacheKey.includes(","))
      childCacheKey = childCacheKey.slice(childCacheKey.indexOf('"'), childCacheKey.indexOf("}"));
    cacheKey += `,${property2}${index !== void 0 ? "/" + index : ""}:${childCacheKey}`;
  }
  cacheKey += "}";
  return cacheKey;
}
function* getNodeChildren(node, toJSON = false) {
  for (const property2 in node) {
    if (property2.startsWith("_") === true)
      continue;
    const object = node[property2];
    if (Array.isArray(object) === true) {
      for (let i = 0; i < object.length; i++) {
        const child = object[i];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: i, childNode: child };
        }
      }
    } else if (object && object.isNode === true) {
      yield { property: property2, childNode: object };
    } else if (typeof object === "object") {
      for (const subProperty in object) {
        const child = object[subProperty];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: subProperty, childNode: child };
        }
      }
    }
  }
}
function getValueType(value) {
  if (value === void 0 || value === null)
    return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if ((last4 === "vec2" || last4 === "vec3" || last4 === "vec4") && params.length === 1) {
    params = last4 === "vec2" ? [params[0], params[0]] : [params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function arrayBufferToBase64(arrayBuffer2) {
  let chars = "";
  const array = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array.length; i++) {
    chars += String.fromCharCode(array[i]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;
}

// node_modules/three/examples/jsm/nodes/core/Node.js
var NodeClasses = /* @__PURE__ */ new Map();
var _nodeId = 0;
var Node = class {
  constructor(nodeType = null) {
    this.isNode = true;
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  get type() {
    return this.constructor.name;
  }
  isGlobal() {
    return false;
  }
  *getChildren() {
    const self = this;
    for (const { property: property2, index, childNode } of getNodeChildren(this)) {
      if (index !== void 0) {
        yield { childNode, replaceNode(node) {
          self[property2][index] = node;
        } };
      } else {
        yield { childNode, replaceNode(node) {
          self[property2] = node;
        } };
      }
    }
  }
  traverse(callback, replaceNode = null) {
    callback(this, replaceNode);
    for (const { childNode, replaceNode: replaceNode2 } of this.getChildren()) {
      childNode.traverse(callback, replaceNode2);
    }
  }
  getCacheKey() {
    return getCacheKey(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType() {
    return this.nodeType;
  }
  getReference(builder) {
    const hash = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash);
    return nodeFromHash || this;
  }
  construct(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    for (const { childNode } of this.getChildren()) {
      nodeProperties["_node" + childNode.id] = childNode;
    }
    return null;
  }
  analyze(builder) {
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    if (nodeData.dependenciesCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder);
        }
      }
    }
  }
  generate(builder, output) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output);
    }
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(builder, output = null) {
    const refNode = this.getReference(builder);
    if (this !== refNode) {
      return refNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "construct") {
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true || builder.context.tempRead === false) {
        properties.initialized = true;
        properties.outputNode = this.construct(builder);
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            childNode.build(builder);
          }
        }
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        }
        result = builder.format(result, type, output);
      } else {
        result = this.generate(builder, output) || "";
      }
    }
    builder.removeChain(this);
    return result;
  }
  getSerializeChildren() {
    return getNodeChildren(this);
  }
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property2, index, childNode } of nodeChildren) {
      if (index !== void 0) {
        if (inputNodes[property2] === void 0) {
          inputNodes[property2] = Number.isInteger(index) ? [] : {};
        }
        inputNodes[property2][index] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property2] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property2])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property2]) {
            inputArray.push(nodes[uuid]);
          }
          this[property2] = inputArray;
        } else if (typeof json.inputNodes[property2] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property2]) {
            const uuid = json.inputNodes[property2][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property2] = inputObject;
        } else {
          const uuid = json.inputNodes[property2];
          this[property2] = nodes[uuid];
        }
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.6,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true)
        meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
var Node_default = Node;
function addNodeClass(nodeClass) {
  if (typeof nodeClass !== "function" || !nodeClass.name)
    throw new Error(`Node class ${nodeClass.name} is not a class`);
  if (NodeClasses.has(nodeClass.name))
    throw new Error(`Redefinition of node class ${nodeClass.name}`);
  NodeClasses.set(nodeClass.name, nodeClass);
}
function createNodeFromType(type) {
  const Class = NodeClasses.get(type);
  if (Class !== void 0) {
    return new Class();
  }
}

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray)
      data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer")
      data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray)
      this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var InputNode_default = InputNode;
addNodeClass(InputNode);

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;
addNodeClass(ArrayElementNode);

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output);
  }
};
var ConvertNode_default = ConvertNode;
addNodeClass(ConvertNode);

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
    this.isTempNode = true;
  }
  hasDependencies(builder) {
    return builder.getDataFromNode(this).dependenciesCount > 1;
  }
  build(builder, output) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output));
      const nodeData = builder.getDataFromNode(this);
      if (builder.context.tempRead !== false && nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output);
      } else if (builder.context.tempWrite !== false && type !== "void" && output !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output);
      }
    }
    return super.build(builder, output);
  }
};
var TempNode_default = TempNode;
addNodeClass(TempNode);

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends TempNode_default {
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (const input of nodes) {
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output);
  }
};
var JoinNode_default = JoinNode;
addNodeClass(JoinNode);

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var stringVectorComponents = vectorComponents.join("");
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder, output) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);
      }
    } else {
      snippet = node.build(builder, output);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;
addNodeClass(SplitNode);

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output);
  }
};
var ConstNode_default = ConstNode;
addNodeClass(ConstNode);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var NodeElements = /* @__PURE__ */ new Map();
function addNodeElement(name, nodeElement) {
  if (NodeElements.has(name))
    throw new Error(`Redefinition of node element ${name}`);
  if (typeof nodeElement !== "function")
    throw new Error(`Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
}
var shaderNodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get: function(node, prop, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (NodeElements.has(prop)) {
        const nodeElement = NodeElements.get(prop);
        return (...params) => nodeElement(nodeObj, ...params);
      } else if (prop.endsWith("Assign") && NodeElements.has(prop.slice(0, prop.length - "Assign".length))) {
        const nodeElement = NodeElements.get(prop.slice(0, prop.length - "Assign".length));
        return (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));
      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return nodeObject(new SplitNode_default(node, prop));
      } else if (prop === "width" || prop === "height") {
        return nodeObject(new SplitNode_default(node, prop === "width" ? "x" : "y"));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(node, new ConstNode_default(Number(prop), "uint")));
      }
    }
    return node[prop];
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    let nodeObject2 = nodeObjectsCacheMap.get(obj);
    if (nodeObject2 === void 0) {
      nodeObject2 = new Proxy(obj, shaderNodeHandler);
      nodeObjectsCacheMap.set(obj, nodeObject2);
      nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
    }
    return nodeObject2;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return shader(obj);
  }
  return obj;
};
var ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
var ShaderNodeArray = function(array, altType = null) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i], altType);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  const assignNode = (node) => nodeObject(settings !== null ? Object.assign(node, settings) : node);
  if (scope === null) {
    return (...params) => {
      return assignNode(new NodeClass(...nodeArray(params)));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));
    };
  } else {
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params)));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderNodeInternal = class extends Node_default {
  constructor(jsFunc) {
    super();
    this._jsFunc = jsFunc;
  }
  call(inputs, stack2, builder) {
    inputs = nodeObjects(inputs);
    return nodeObject(this._jsFunc(inputs, stack2, builder));
  }
  getNodeType(builder) {
    const { outputNode } = builder.getNodeProperties(this);
    return outputNode ? outputNode.getNodeType(builder) : super.getNodeType(builder);
  }
  construct(builder) {
    builder.addStack();
    builder.stack.outputNode = nodeObject(this._jsFunc(builder.stack, builder));
    return builder.removeStack();
  }
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (const int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (const float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (const float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value, type);
  }
};
var safeGetNodeType = (node) => {
  try {
    return node.getNodeType();
  } catch {
    return void 0;
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => typeof param !== "object")) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObject(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (safeGetNodeType(node) === type)
        return nodeObject(node);
      return nodeObject(new ConvertNode_default(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObject(new JoinNode_default(nodes, type));
  };
};
var getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc) {
  return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);
}
var nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
var nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
var nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
var nodeProxy = (...val) => new ShaderNodeProxy(...val);
var nodeImmutable = (...val) => new ShaderNodeImmutable(...val);
var shader = (...val) => new ShaderNode(...val);
addNodeClass(ShaderNode);
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.int);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var string = (value = "") => nodeObject(new ConstNode_default(value, "string"));
var arrayBuffer = (value) => nodeObject(new ConstNode_default(value, "ArrayBuffer"));
addNodeElement("color", color);
addNodeElement("float", float);
addNodeElement("int", int);
addNodeElement("uint", uint);
addNodeElement("bool", bool);
addNodeElement("vec2", vec2);
addNodeElement("ivec2", ivec2);
addNodeElement("uvec2", uvec2);
addNodeElement("bvec2", bvec2);
addNodeElement("vec3", vec3);
addNodeElement("ivec3", ivec3);
addNodeElement("uvec3", uvec3);
addNodeElement("bvec3", bvec3);
addNodeElement("vec4", vec4);
addNodeElement("ivec4", ivec4);
addNodeElement("uvec4", uvec4);
addNodeElement("bvec4", bvec4);
addNodeElement("mat3", mat3);
addNodeElement("imat3", imat3);
addNodeElement("umat3", umat3);
addNodeElement("bmat3", bmat3);
addNodeElement("mat4", mat4);
addNodeElement("imat4", imat4);
addNodeElement("umat4", umat4);
addNodeElement("bmat4", bmat4);
addNodeElement("string", string);
addNodeElement("arrayBuffer", arrayBuffer);
var element = nodeProxy(ArrayElementNode_default);
var convert = (node, types) => nodeObject(new ConvertNode_default(nodeObject(node), types));
var split = (node, channels) => nodeObject(new SplitNode_default(nodeObject(node), channels));
addNodeElement("element", element);
addNodeElement("convert", convert);

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
  }
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const hash = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type, output);
  }
};
var UniformNode_default = UniformNode;
var uniform = (arg1, arg2) => {
  const nodeType = getConstNodeType(arg2 || arg1);
  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;
  return nodeObject(new UniformNode(value, nodeType));
};
addNodeClass(UniformNode);

// node_modules/three/examples/jsm/nodes/core/ArrayUniformNode.js
var ArrayUniformNode = class extends UniformNode_default {
  constructor(nodes = []) {
    super();
    this.isArrayUniformNode = true;
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return this.nodes[0].getNodeType(builder);
  }
};
var ArrayUniformNode_default = ArrayUniformNode;
addNodeClass(ArrayUniformNode);

// node_modules/three/examples/jsm/nodes/core/VaryingNode.js
var VaryingNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const { name, node } = this;
    const type = this.getNodeType(builder);
    const nodeVarying = builder.getVaryingFromNode(this, type);
    nodeVarying.needsInterpolation || (nodeVarying.needsInterpolation = builder.shaderStage === "fragment");
    if (name !== null) {
      nodeVarying.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVarying, NodeShaderStage.VERTEX);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, node, type, propertyName);
    return builder.getPropertyName(nodeVarying);
  }
};
var VaryingNode_default = VaryingNode;
var varying = nodeProxy(VaryingNode);
addNodeElement("varying", varying);
addNodeClass(VaryingNode);

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    const attributeName = this.getAttributeName(builder);
    let nodeType = super.getNodeType(builder);
    if (nodeType === null) {
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute2 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute2);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute2 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute2);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      console.warn(`AttributeNode: Attribute "${attributeName}" not found.`);
      return builder.getConst(nodeType);
    }
  }
};
var AttributeNode_default = AttributeNode;
var attribute = (name, nodeType) => nodeObject(new AttributeNode(name, nodeType));
addNodeClass(AttributeNode);

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder, output) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet);
    }
    return this.outputNode.build(builder, output);
  }
};
var BypassNode_default = BypassNode;
var bypass = nodeProxy(BypassNode);
addNodeElement("bypass", bypass);
addNodeClass(BypassNode);

// node_modules/three/examples/jsm/nodes/core/NodeCache.js
var id = 0;
var NodeCache = class {
  constructor() {
    this.id = id++;
    this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(node) {
    return this.nodesData.get(node);
  }
  setNodeData(node, data) {
    this.nodesData.set(node, data);
  }
};
var NodeCache_default = NodeCache;

// node_modules/three/examples/jsm/nodes/core/CacheNode.js
var CacheNode = class extends Node_default {
  constructor(node, cache2 = new NodeCache_default()) {
    super();
    this.isCacheNode = true;
    this.node = node;
    this.cache = cache2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    builder.setCache(this.cache);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
};
var CacheNode_default = CacheNode;
var cache = nodeProxy(CacheNode);
addNodeElement("cache", cache);
addNodeClass(CacheNode);

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  construct(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
};
var ContextNode_default = ContextNode;
var context = nodeProxy(ContextNode);
addNodeElement("context", context);
addNodeClass(ContextNode);

// node_modules/three/examples/jsm/nodes/core/InstanceIndexNode.js
var InstanceIndexNode = class extends Node_default {
  constructor() {
    super("uint");
    this.isInstanceIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const propertyName = builder.getInstanceIndex();
    let output = null;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output = propertyName;
    } else {
      const nodeVarying = varying(this);
      output = nodeVarying.build(builder, nodeType);
    }
    return output;
  }
};
var InstanceIndexNode_default = InstanceIndexNode;
var instanceIndex = nodeImmutable(InstanceIndexNode);
addNodeClass(InstanceIndexNode);

// node_modules/three/examples/jsm/nodes/core/LightingModel.js
var LightingModel = class {
  constructor(direct = null, indirectDiffuse = null, indirectSpecular = null, ambientOcclusion = null) {
    this.direct = direct;
    this.indirectDiffuse = indirectDiffuse;
    this.indirectSpecular = indirectSpecular;
    this.ambientOcclusion = ambientOcclusion;
  }
};
var LightingModel_default = LightingModel;
var lightingModel = (...params) => new LightingModel(...params);

// node_modules/three/examples/jsm/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type, node = null) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
};
var NodeAttribute_default = NodeAttribute;

// node_modules/three/examples/jsm/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type, node, needsUpdate = void 0) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node;
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
};
var NodeUniform_default = NodeUniform;

// node_modules/three/examples/jsm/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
  }
};
var NodeVar_default = NodeVar;

// node_modules/three/examples/jsm/nodes/core/NodeVarying.js
var NodeVarying = class extends NodeVar_default {
  constructor(name, type) {
    super(name, type);
    this.needsInterpolation = false;
    this.isNodeVarying = true;
  }
};
var NodeVarying_default = NodeVarying;

// node_modules/three/examples/jsm/nodes/core/NodeCode.js
var NodeCode = class {
  constructor(name, type, code2 = "") {
    this.name = name;
    this.type = type;
    this.code = code2;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
};
var NodeCode_default = NodeCode;

// node_modules/three/examples/jsm/nodes/core/NodeKeywords.js
var NodeKeywords = class {
  constructor() {
    this.keywords = [];
    this.nodes = [];
    this.keywordsCallback = {};
  }
  getNode(name) {
    let node = this.nodes[name];
    if (node === void 0 && this.keywordsCallback[name] !== void 0) {
      node = this.keywordsCallback[name](name);
      this.nodes[name] = node;
    }
    return node;
  }
  addKeyword(name, callback) {
    this.keywords.push(name);
    this.keywordsCallback[name] = callback;
    return this;
  }
  parse(code2) {
    const keywordNames = this.keywords;
    const regExp = new RegExp(`\\b${keywordNames.join("\\b|\\b")}\\b`, "g");
    const codeKeywords = code2.match(regExp);
    const keywordNodes = [];
    if (codeKeywords !== null) {
      for (const keyword of codeKeywords) {
        const node = this.getNode(keyword);
        if (node !== void 0 && keywordNodes.indexOf(node) === -1) {
          keywordNodes.push(node);
        }
      }
    }
    return keywordNodes;
  }
  include(builder, code2) {
    const keywordNodes = this.parse(code2);
    for (const keywordNode of keywordNodes) {
      keywordNode.build(builder);
    }
  }
};
var NodeKeywords_default = NodeKeywords;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(nodeType, name = null) {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  isGlobal() {
    return true;
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;
var property = (type, name) => nodeObject(new PropertyNode(type, name));
var diffuseColor = nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
var roughness = nodeImmutable(PropertyNode, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode, "float", "Metalness");
var specularColor = nodeImmutable(PropertyNode, "color", "SpecularColor");
var shininess = nodeImmutable(PropertyNode, "float", "Shininess");
addNodeClass(PropertyNode);

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.isUVNode = true;
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index + 1 : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var UVNode_default = UVNode;
var uv = (...params) => nodeObject(new UVNode(...params));
addNodeClass(UVNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var defaultUV;
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    if (this.value.isDepthTexture === true)
      return "float";
    return "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return defaultUV || (defaultUV = uv());
  }
  construct(builder) {
    const properties = builder.getNodeProperties(this);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUVNode) {
      uvNode = builder.context.getUVNode(this);
    }
    uvNode || (uvNode = this.getDefaultUV());
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getSamplerLevelNode) {
      levelNode = builder.context.getSamplerLevelNode(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode ? builder.context.getMIPLevelAlgorithmNode(this, levelNode) : null;
  }
  generate(builder, output) {
    const { uvNode, levelNode } = builder.getNodeProperties(this);
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "property");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeType = this.getNodeType(builder);
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const uvSnippet = uvNode.build(builder, "vec2");
        const nodeVar = builder.getVarFromNode(this, nodeType);
        propertyName = builder.getPropertyName(nodeVar);
        let snippet = null;
        if (levelNode && levelNode.isNode === true) {
          const levelSnippet = levelNode.build(builder, "float");
          snippet = builder.getTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet);
        } else {
          snippet = builder.getTexture(texture2, textureProperty, uvSnippet);
        }
        builder.addLineFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
      }
      return builder.format(propertyName, nodeType, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
};
var TextureNode_default = TextureNode;
var texture = nodeProxy(TextureNode);
var sampler = (aTexture) => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert("sampler");
addNodeElement("texture", texture);
addNodeClass(TextureNode);

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType.OBJECT;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    let node = null;
    if (uniformType === "texture") {
      node = texture(null);
    } else {
      node = uniform(uniformType);
    }
    this.node = node;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const property2 = this.property;
    this.node.value = object[property2];
  }
  construct() {
    return this.node;
  }
};
var ReferenceNode_default = ReferenceNode;
var reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));
addNodeClass(ReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
  }
  construct(builder) {
    const material = this.material !== null ? this.material : builder.material;
    this.node.value = material[this.property];
    return super.construct(builder);
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;
var materialReference = (name, type, material) => nodeObject(new MaterialReferenceNode(name, type, material));
addNodeClass(MaterialReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var MaterialNode = class extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
  }
  getNodeType(builder) {
    const scope = this.scope;
    const material = builder.context.material;
    if (scope === MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope === MaterialNode.OPACITY || scope === MaterialNode.ROTATION) {
      return "float";
    } else if (scope === MaterialNode.UV) {
      return "vec2";
    } else if (scope === MaterialNode.EMISSIVE) {
      return "vec3";
    } else if (scope === MaterialNode.ROUGHNESS || scope === MaterialNode.METALNESS || scope === MaterialNode.SPECULAR || scope === MaterialNode.SHININESS) {
      return "float";
    }
  }
  getFloat(property2) {
    return materialReference(property2, "float");
  }
  getColor(property2) {
    return materialReference(property2, "color");
  }
  getTexture(property2) {
    const textureRefNode = materialReference(property2, "texture");
    textureRefNode.node.uvNode = materialUV;
    return textureRefNode;
  }
  construct(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === MaterialNode.ALPHA_TEST) {
      node = this.getFloat("alphaTest");
    } else if (scope === MaterialNode.COLOR) {
      const colorNode = this.getColor("color");
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === MaterialNode.OPACITY) {
      const opacityNode = this.getFloat("opacity");
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture("alphaMap"));
      } else {
        node = opacityNode;
      }
    } else if (scope === MaterialNode.SHININESS) {
      node = this.getFloat("shininess");
    } else if (scope === MaterialNode.SPECULAR_COLOR) {
      node = this.getColor("specular");
    } else if (scope === MaterialNode.REFLECTIVITY) {
      const reflectivityNode = this.getFloat("reflectivity");
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = reflectivityNode.mul(this.getTexture("specularMap").r);
      } else {
        node = reflectivityNode;
      }
    } else if (scope === MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat("roughness");
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture("roughnessMap").g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat("metalness");
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture("metalnessMap").b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === MaterialNode.EMISSIVE) {
      const emissiveNode = this.getColor("emissive");
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture("emissiveMap"));
      } else {
        node = emissiveNode;
      }
    } else if (scope === MaterialNode.ROTATION) {
      node = this.getFloat("rotation");
    } else if (scope === MaterialNode.UV) {
      let uvScaleMap = material.map || material.specularMap || material.displacementMap || material.normalMap || material.bumpMap || material.roughnessMap || material.metalnessMap || material.alphaMap || material.emissiveMap || material.clearcoatMap || material.clearcoatNormalMap || material.clearcoatRoughnessMap || material.iridescenceMap || material.iridescenceThicknessMap || material.specularIntensityMap || material.specularColorMap || material.transmissionMap || material.thicknessMap || material.sheenColorMap || material.sheenRoughnessMap;
      if (uvScaleMap) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        node = uniform(uvScaleMap.matrix).mul(vec3(uv(), 1));
      } else {
        node = uv();
      }
    } else {
      const outputType = this.getNodeType(builder);
      node = materialReference(scope, outputType);
    }
    return node;
  }
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.UV = "uv";
var MaterialNode_default = MaterialNode;
var materialUV = nodeImmutable(MaterialNode, MaterialNode.UV);
var materialAlphaTest = nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode, MaterialNode.COLOR);
var materialShininess = nodeImmutable(MaterialNode, MaterialNode.SHININESS);
var materialEmissive = nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode, MaterialNode.OPACITY);
var materialSpecularColor = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
var materialReflectivity = nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
var materialRoughness = nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode, MaterialNode.METALNESS);
var materialRotation = nodeImmutable(MaterialNode, MaterialNode.ROTATION);
addNodeClass(MaterialNode);

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  assign(node) {
    node.traverse((childNode, replaceNode) => {
      if (replaceNode && childNode.uuid === this.uuid) {
        replaceNode(this.node);
      }
    });
    this.node = node;
    return this;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const node = this.node;
    const name = this.name;
    if (name === null && node.isTempNode === true) {
      return node.build(builder);
    }
    const type = builder.getVectorType(this.getNodeType(builder));
    const snippet = node.build(builder, type);
    const nodeVar = builder.getVarFromNode(this, type);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addLineFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var VarNode_default = VarNode;
var label = nodeProxy(VarNode);
var temp = label;
addNodeElement("label", label);
addNodeElement("temp", temp);
addNodeClass(VarNode);

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  hasDependencies(builder) {
    return this.op !== "=" ? super.hasDependencies(builder) : false;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = output ? builder.getTypeLength(output) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output);
    if (output !== "void") {
      if (op === "=") {
        builder.addLineFlowCode(`${a} ${this.op} ${b}`);
        return a;
      } else if (op === "<" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThan")}( ${a}, ${b} )`, type, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output);
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output);
      } else if (op === ">=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThanEqual")}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a} ${this.op} ${b}`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;
var add = nodeProxy(OperatorNode, "+");
var sub = nodeProxy(OperatorNode, "-");
var mul = nodeProxy(OperatorNode, "*");
var div = nodeProxy(OperatorNode, "/");
var remainder = nodeProxy(OperatorNode, "%");
var equal = nodeProxy(OperatorNode, "==");
var assign = nodeProxy(OperatorNode, "=");
var lessThan = nodeProxy(OperatorNode, "<");
var greaterThan = nodeProxy(OperatorNode, ">");
var lessThanEqual = nodeProxy(OperatorNode, "<=");
var greaterThanEqual = nodeProxy(OperatorNode, ">=");
var and = nodeProxy(OperatorNode, "&&");
var or = nodeProxy(OperatorNode, "||");
var xor = nodeProxy(OperatorNode, "^^");
var bitAnd = nodeProxy(OperatorNode, "&");
var bitOr = nodeProxy(OperatorNode, "|");
var bitXor = nodeProxy(OperatorNode, "^");
var shiftLeft = nodeProxy(OperatorNode, "<<");
var shiftRight = nodeProxy(OperatorNode, ">>");
addNodeElement("add", add);
addNodeElement("sub", sub);
addNodeElement("mul", mul);
addNodeElement("div", div);
addNodeElement("remainder", remainder);
addNodeElement("equal", equal);
addNodeElement("assign", assign);
addNodeElement("lessThan", lessThan);
addNodeElement("greaterThan", greaterThan);
addNodeElement("lessThanEqual", lessThanEqual);
addNodeElement("greaterThanEqual", greaterThanEqual);
addNodeElement("and", and);
addNodeElement("or", or);
addNodeElement("xor", xor);
addNodeElement("bitAnd", bitAnd);
addNodeElement("bitOr", bitOr);
addNodeElement("bitXor", bitXor);
addNodeElement("shiftLeft", shiftLeft);
addNodeElement("shiftRight", shiftRight);
addNodeClass(OperatorNode);

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var MathNode = class extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {
      return "float";
    } else if (method === MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (method === MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      return normalize(mulNode).build(builder, output);
    } else if (method === MathNode.NEGATE) {
      return builder.format("-" + a.build(builder, inputType), type, output);
    } else if (method === MathNode.ONE_MINUS) {
      return sub(1, a).build(builder, output);
    } else if (method === MathNode.RECIPROCAL) {
      return div(1, a).build(builder, output);
    } else if (method === MathNode.DIFFERENCE) {
      return abs(sub(a, b)).build(builder, output);
    } else {
      const params = [];
      if (method === MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (b !== null)
          params.push(b.build(builder, inputType));
        if (c !== null)
          params.push(c.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.ATAN2 = "atan2";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.MOD = "mod";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
var MathNode_default = MathNode;
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var radians = nodeProxy(MathNode, MathNode.RADIANS);
var degrees = nodeProxy(MathNode, MathNode.DEGREES);
var exp = nodeProxy(MathNode, MathNode.EXP);
var exp2 = nodeProxy(MathNode, MathNode.EXP2);
var log = nodeProxy(MathNode, MathNode.LOG);
var log2 = nodeProxy(MathNode, MathNode.LOG2);
var sqrt = nodeProxy(MathNode, MathNode.SQRT);
var inverseSqrt = nodeProxy(MathNode, MathNode.INVERSE_SQRT);
var floor = nodeProxy(MathNode, MathNode.FLOOR);
var ceil = nodeProxy(MathNode, MathNode.CEIL);
var normalize = nodeProxy(MathNode, MathNode.NORMALIZE);
var fract = nodeProxy(MathNode, MathNode.FRACT);
var sin = nodeProxy(MathNode, MathNode.SIN);
var cos = nodeProxy(MathNode, MathNode.COS);
var tan = nodeProxy(MathNode, MathNode.TAN);
var asin = nodeProxy(MathNode, MathNode.ASIN);
var acos = nodeProxy(MathNode, MathNode.ACOS);
var atan = nodeProxy(MathNode, MathNode.ATAN);
var abs = nodeProxy(MathNode, MathNode.ABS);
var sign = nodeProxy(MathNode, MathNode.SIGN);
var length = nodeProxy(MathNode, MathNode.LENGTH);
var negate = nodeProxy(MathNode, MathNode.NEGATE);
var oneMinus = nodeProxy(MathNode, MathNode.ONE_MINUS);
var dFdx = nodeProxy(MathNode, MathNode.DFDX);
var dFdy = nodeProxy(MathNode, MathNode.DFDY);
var round = nodeProxy(MathNode, MathNode.ROUND);
var reciprocal = nodeProxy(MathNode, MathNode.RECIPROCAL);
var atan2 = nodeProxy(MathNode, MathNode.ATAN2);
var min = nodeProxy(MathNode, MathNode.MIN);
var max = nodeProxy(MathNode, MathNode.MAX);
var mod = nodeProxy(MathNode, MathNode.MOD);
var step = nodeProxy(MathNode, MathNode.STEP);
var reflect = nodeProxy(MathNode, MathNode.REFLECT);
var distance = nodeProxy(MathNode, MathNode.DISTANCE);
var difference = nodeProxy(MathNode, MathNode.DIFFERENCE);
var dot = nodeProxy(MathNode, MathNode.DOT);
var cross = nodeProxy(MathNode, MathNode.CROSS);
var pow = nodeProxy(MathNode, MathNode.POW);
var pow2 = nodeProxy(MathNode, MathNode.POW, 2);
var pow3 = nodeProxy(MathNode, MathNode.POW, 3);
var pow4 = nodeProxy(MathNode, MathNode.POW, 4);
var transformDirection = nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);
var mix = nodeProxy(MathNode, MathNode.MIX);
var clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
var saturate = (value) => clamp(value);
var refract = nodeProxy(MathNode, MathNode.REFRACT);
var smoothstep = nodeProxy(MathNode, MathNode.SMOOTHSTEP);
var faceForward = nodeProxy(MathNode, MathNode.FACEFORWARD);
var mixElement = (t, e1, e2) => mix(e1, e2, t);
var smoothstepElement = (x, low, high) => smoothstep(low, high, x);
addNodeElement("radians", radians);
addNodeElement("degrees", degrees);
addNodeElement("exp", exp);
addNodeElement("exp2", exp2);
addNodeElement("log", log);
addNodeElement("log2", log2);
addNodeElement("sqrt", sqrt);
addNodeElement("inverseSqrt", inverseSqrt);
addNodeElement("floor", floor);
addNodeElement("ceil", ceil);
addNodeElement("normalize", normalize);
addNodeElement("fract", fract);
addNodeElement("sin", sin);
addNodeElement("cos", cos);
addNodeElement("tan", tan);
addNodeElement("asin", asin);
addNodeElement("acos", acos);
addNodeElement("atan", atan);
addNodeElement("abs", abs);
addNodeElement("sign", sign);
addNodeElement("length", length);
addNodeElement("negate", negate);
addNodeElement("oneMinus", oneMinus);
addNodeElement("dFdx", dFdx);
addNodeElement("dFdy", dFdy);
addNodeElement("round", round);
addNodeElement("reciprocal", reciprocal);
addNodeElement("atan2", atan2);
addNodeElement("min", min);
addNodeElement("max", max);
addNodeElement("mod", mod);
addNodeElement("step", step);
addNodeElement("reflect", reflect);
addNodeElement("distance", distance);
addNodeElement("dot", dot);
addNodeElement("cross", cross);
addNodeElement("pow", pow);
addNodeElement("pow2", pow2);
addNodeElement("pow3", pow3);
addNodeElement("pow4", pow4);
addNodeElement("transformDirection", transformDirection);
addNodeElement("mix", mixElement);
addNodeElement("clamp", clamp);
addNodeElement("refract", refract);
addNodeElement("smoothstep", smoothstepElement);
addNodeElement("faceForward", faceForward);
addNodeElement("difference", difference);
addNodeElement("saturate", saturate);
addNodeClass(MathNode);

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var Object3DNode = class extends Node_default {
  constructor(scope = Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this._uniformNode = uniform(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION) {
      this._uniformNode.nodeType = "vec3";
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
Object3DNode.VIEW_MATRIX = "viewMatrix";
Object3DNode.NORMAL_MATRIX = "normalMatrix";
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
var Object3DNode_default = Object3DNode;
var objectDirection = nodeProxy(Object3DNode, Object3DNode.DIRECTION);
var objectViewMatrix = nodeProxy(Object3DNode, Object3DNode.VIEW_MATRIX);
var objectNormalMatrix = nodeProxy(Object3DNode, Object3DNode.NORMAL_MATRIX);
var objectWorldMatrix = nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);
var objectPosition = nodeProxy(Object3DNode, Object3DNode.POSITION);
var objectViewPosition = nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);
addNodeClass(Object3DNode);

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var CameraNode = class extends Object3DNode_default {
  constructor(scope = CameraNode.POSITION) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    }
    return super.generate(builder);
  }
};
CameraNode.PROJECTION_MATRIX = "projectionMatrix";
var CameraNode_default = CameraNode;
var cameraProjectionMatrix = nodeImmutable(CameraNode, CameraNode.PROJECTION_MATRIX);
var cameraViewMatrix = nodeImmutable(CameraNode, CameraNode.VIEW_MATRIX);
var cameraNormalMatrix = nodeImmutable(CameraNode, CameraNode.NORMAL_MATRIX);
var cameraWorldMatrix = nodeImmutable(CameraNode, CameraNode.WORLD_MATRIX);
var cameraPosition = nodeImmutable(CameraNode, CameraNode.POSITION);
addNodeClass(CameraNode);

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class extends Object3DNode_default {
  constructor(scope = ModelNode.VIEW_MATRIX) {
    super(scope);
  }
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var ModelNode_default = ModelNode;
var modelDirection = nodeImmutable(ModelNode, ModelNode.DIRECTION);
var modelViewMatrix = nodeImmutable(ModelNode, ModelNode.VIEW_MATRIX);
var modelNormalMatrix = nodeImmutable(ModelNode, ModelNode.NORMAL_MATRIX);
var modelWorldMatrix = nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode, ModelNode.POSITION);
var modelViewPosition = nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
addNodeClass(ModelNode);

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var NormalNode = class extends Node_default {
  constructor(scope = NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  isGlobal() {
    return true;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === NormalNode.GEOMETRY) {
      outputNode = attribute("normal", "vec3");
    } else if (scope === NormalNode.LOCAL) {
      outputNode = varying(normalGeometry);
    } else if (scope === NormalNode.VIEW) {
      const vertexNode = modelNormalMatrix.mul(normalLocal);
      outputNode = normalize(varying(vertexNode));
    } else if (scope === NormalNode.WORLD) {
      const vertexNode = normalView.transformDirection(cameraViewMatrix);
      outputNode = normalize(varying(vertexNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
NormalNode.GEOMETRY = "geometry";
NormalNode.LOCAL = "local";
NormalNode.VIEW = "view";
NormalNode.WORLD = "world";
var NormalNode_default = NormalNode;
var normalGeometry = nodeImmutable(NormalNode, NormalNode.GEOMETRY);
var normalLocal = nodeImmutable(NormalNode, NormalNode.LOCAL);
var normalView = nodeImmutable(NormalNode, NormalNode.VIEW);
var normalWorld = nodeImmutable(NormalNode, NormalNode.WORLD);
var transformedNormalView = label(normalView, "TransformedNormalView");
var transformedNormalWorld = transformedNormalView.transformDirection(cameraViewMatrix).normalize();
addNodeClass(NormalNode);

// node_modules/three/examples/jsm/nodes/accessors/TangentNode.js
var TangentNode = class extends Node_default {
  constructor(scope = TangentNode.LOCAL) {
    super();
    this.scope = scope;
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === TangentNode.GEOMETRY) {
      return "vec4";
    }
    return "vec3";
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === TangentNode.GEOMETRY) {
      outputNode = attribute("tangent", "vec4");
    } else if (scope === TangentNode.LOCAL) {
      outputNode = varying(tangentGeometry.xyz);
    } else if (scope === TangentNode.VIEW) {
      const vertexNode = modelViewMatrix.mul(tangentLocal).xyz;
      outputNode = normalize(varying(vertexNode));
    } else if (scope === TangentNode.WORLD) {
      const vertexNode = tangentView.transformDirection(cameraViewMatrix);
      outputNode = normalize(varying(vertexNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
TangentNode.GEOMETRY = "geometry";
TangentNode.LOCAL = "local";
TangentNode.VIEW = "view";
TangentNode.WORLD = "world";
var TangentNode_default = TangentNode;
var tangentGeometry = nodeImmutable(TangentNode, TangentNode.GEOMETRY);
var tangentLocal = nodeImmutable(TangentNode, TangentNode.LOCAL);
var tangentView = nodeImmutable(TangentNode, TangentNode.VIEW);
var tangentWorld = nodeImmutable(TangentNode, TangentNode.WORLD);
var transformedTangentView = label(tangentView, "TransformedTangentView");
var transformedTangentWorld = normalize(transformedTangentView.transformDirection(cameraViewMatrix));
addNodeClass(TangentNode);

// node_modules/three/examples/jsm/nodes/accessors/BitangentNode.js
var BitangentNode = class extends Node_default {
  constructor(scope = BitangentNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let crossNormalTangent;
    if (scope === BitangentNode.GEOMETRY) {
      crossNormalTangent = normalGeometry.cross(tangentGeometry);
    } else if (scope === BitangentNode.LOCAL) {
      crossNormalTangent = normalLocal.cross(tangentLocal);
    } else if (scope === BitangentNode.VIEW) {
      crossNormalTangent = normalView.cross(tangentView);
    } else if (scope === BitangentNode.WORLD) {
      crossNormalTangent = normalWorld.cross(tangentWorld);
    }
    const vertexNode = crossNormalTangent.mul(tangentGeometry.w).xyz;
    const outputNode = normalize(varying(vertexNode));
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
BitangentNode.GEOMETRY = "geometry";
BitangentNode.LOCAL = "local";
BitangentNode.VIEW = "view";
BitangentNode.WORLD = "world";
var BitangentNode_default = BitangentNode;
var bitangentGeometry = nodeImmutable(BitangentNode, BitangentNode.GEOMETRY);
var bitangentLocal = nodeImmutable(BitangentNode, BitangentNode.LOCAL);
var bitangentView = nodeImmutable(BitangentNode, BitangentNode.VIEW);
var bitangentWorld = nodeImmutable(BitangentNode, BitangentNode.WORLD);
var transformedBitangentView = normalize(transformedNormalView.cross(transformedTangentView).mul(tangentGeometry.w));
var transformedBitangentWorld = normalize(transformedBitangentView.transformDirection(cameraViewMatrix));
addNodeClass(BitangentNode);

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var PositionNode = class extends Node_default {
  constructor(scope = PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  isGlobal() {
    return true;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === PositionNode.GEOMETRY) {
      outputNode = attribute("position", "vec3");
    } else if (scope === PositionNode.LOCAL) {
      outputNode = varying(positionGeometry);
    } else if (scope === PositionNode.WORLD) {
      const vertexPositionNode = modelWorldMatrix.mul(positionLocal);
      outputNode = varying(vertexPositionNode);
    } else if (scope === PositionNode.VIEW) {
      const vertexPositionNode = modelViewMatrix.mul(positionLocal);
      outputNode = varying(vertexPositionNode);
    } else if (scope === PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = positionView.negate();
      outputNode = normalize(varying(vertexPositionNode));
    } else if (scope === PositionNode.WORLD_DIRECTION) {
      const vertexPositionNode = positionLocal.transformDirection(modelWorldMatrix);
      outputNode = normalize(varying(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
PositionNode.GEOMETRY = "geometry";
PositionNode.LOCAL = "local";
PositionNode.WORLD = "world";
PositionNode.WORLD_DIRECTION = "worldDirection";
PositionNode.VIEW = "view";
PositionNode.VIEW_DIRECTION = "viewDirection";
var PositionNode_default = PositionNode;
var positionGeometry = nodeImmutable(PositionNode, PositionNode.GEOMETRY);
var positionLocal = nodeImmutable(PositionNode, PositionNode.LOCAL);
var positionWorld = nodeImmutable(PositionNode, PositionNode.WORLD);
var positionWorldDirection = nodeImmutable(PositionNode, PositionNode.WORLD_DIRECTION);
var positionView = nodeImmutable(PositionNode, PositionNode.VIEW);
var positionViewDirection = nodeImmutable(PositionNode, PositionNode.VIEW_DIRECTION);
addNodeClass(PositionNode);

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    return builder.getFrontFacing();
  }
};
var FrontFacingNode_default = FrontFacingNode;
var frontFacing = nodeImmutable(FrontFacingNode);
var faceDirection = float(frontFacing).mul(2).sub(1);
addNodeClass(FrontFacingNode);

// node_modules/three/examples/jsm/nodes/display/NormalMapNode.js
var perturbNormal2ArbNode = new ShaderNode((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;
  const q0 = eye_pos.dFdx();
  const q1 = eye_pos.dFdy();
  const st0 = uv2.dFdx();
  const st1 = uv2.dFdy();
  const N = surf_norm;
  const q1perp = q1.cross(N);
  const q0perp = N.cross(q0);
  const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
  const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
  const det = T.dot(T).max(B.dot(B));
  const scale = faceDirection.mul(det.inverseSqrt());
  return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  construct(builder) {
    const { normalMapType, scaleNode } = this;
    let normalMap2 = this.node.mul(2).sub(1);
    if (scaleNode !== null) {
      normalMap2 = vec3(normalMap2.xy.mul(scaleNode), normalMap2.z);
    }
    let outputNode = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      outputNode = modelNormalMatrix.mul(normalMap2).normalize();
    } else if (normalMapType === TangentSpaceNormalMap) {
      const tangent = builder.hasGeometryAttribute("tangent");
      if (tangent === true) {
        outputNode = TBNViewMatrix.mul(normalMap2).normalize();
      } else {
        outputNode = perturbNormal2ArbNode.call({
          eye_pos: positionView,
          surf_norm: normalView,
          mapN: normalMap2,
          uv: uv()
        });
      }
    }
    return outputNode;
  }
};
var NormalMapNode_default = NormalMapNode;
var normalMap = nodeProxy(NormalMapNode);
var TBNViewMatrix = mat3(tangentView, bitangentView, normalView);
addNodeClass(NormalMapNode);

// node_modules/three/examples/jsm/nodes/accessors/ExtendedMaterialNode.js
var ExtendedMaterialNode = class extends MaterialNode_default {
  constructor(scope) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    let type = null;
    if (scope === ExtendedMaterialNode.NORMAL) {
      type = "vec3";
    }
    return type || super.getNodeType(builder);
  }
  construct(builder) {
    const material = builder.material;
    const scope = this.scope;
    let node = null;
    if (scope === ExtendedMaterialNode.NORMAL) {
      node = material.normalMap ? normalMap(this.getTexture("normalMap"), materialReference("normalScale", "vec2")) : normalView;
    }
    return node || super.construct(builder);
  }
};
ExtendedMaterialNode.NORMAL = "normal";
var ExtendedMaterialNode_default = ExtendedMaterialNode;
var materialNormal = nodeImmutable(ExtendedMaterialNode, ExtendedMaterialNode.NORMAL);
addNodeClass(ExtendedMaterialNode);

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends Node_default {
  constructor(positionNode = positionLocal) {
    super("vec4");
    this.positionNode = positionNode;
  }
  construct() {
    return cameraProjectionMatrix.mul(modelViewMatrix).mul(this.positionNode);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;
var modelViewProjection = nodeProxy(ModelViewProjectionNode);
addNodeClass(ModelViewProjectionNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferAttributeNode.js
var BufferAttributeNode = class extends InputNode_default {
  constructor(value, bufferType, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
  }
  construct(builder) {
    const type = this.getNodeType(builder);
    const array = this.value;
    const itemSize = builder.getTypeLength(type);
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    const buffer2 = new InterleavedBuffer(array, stride);
    const bufferAttribute2 = new InterleavedBufferAttribute(buffer2, itemSize, offset);
    buffer2.setUsage(this.usage);
    this.attribute = bufferAttribute2;
    this.attribute.isInstancedBufferAttribute = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeUniform = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    let output = null;
    if (builder.shaderStage === "vertex") {
      output = propertyName;
    } else {
      const nodeVarying = varying(this);
      output = nodeVarying.build(builder, nodeType);
    }
    return output;
  }
  getInputType() {
    return "bufferAttribute";
  }
};
var BufferAttributeNode_default = BufferAttributeNode;
var bufferAttribute = (array, type, stride, offset) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
var dynamicBufferAttribute = (array, type, stride, offset) => {
  const node = bufferAttribute(array, type, stride, offset);
  node.usage = DynamicDrawUsage;
  return node;
};
addNodeClass(BufferAttributeNode);

// node_modules/three/examples/jsm/nodes/accessors/InstanceNode.js
var InstanceNode = class extends Node_default {
  constructor(instanceMesh) {
    super("void");
    this.instanceMesh = instanceMesh;
    this.instanceMatrixNode = null;
  }
  construct(builder) {
    let instanceMatrixNode = this.instanceMatrixNode;
    if (instanceMatrixNode === null) {
      const instanceMesh = this.instanceMesh;
      const instaceAttribute = instanceMesh.instanceMatrix;
      const array = instaceAttribute.array;
      const bufferFn = instaceAttribute.usage === DynamicDrawUsage ? dynamicBufferAttribute : bufferAttribute;
      const instanceBuffers = [
        // F.Signature -> bufferAttribute( array, type, stride, offset )
        bufferFn(array, "vec4", 16, 0),
        bufferFn(array, "vec4", 16, 4),
        bufferFn(array, "vec4", 16, 8),
        bufferFn(array, "vec4", 16, 12)
      ];
      instanceMatrixNode = mat4(...instanceBuffers);
      this.instanceMatrixNode = instanceMatrixNode;
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
    const m = mat3(instanceMatrixNode[0].xyz, instanceMatrixNode[1].xyz, instanceMatrixNode[2].xyz);
    const transformedNormal = normalLocal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
    const instanceNormal = m.mul(transformedNormal).xyz;
    builder.stack.assign(positionLocal, instancePosition);
    builder.stack.assign(normalLocal, instanceNormal);
    return builder.stack;
  }
};
var InstanceNode_default = InstanceNode;
var instance = nodeProxy(InstanceNode);
addNodeClass(InstanceNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
var BufferNode_default = BufferNode;
var buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));
addNodeClass(BufferNode);

// node_modules/three/examples/jsm/nodes/accessors/SkinningNode.js
var Skinning = new ShaderNode((inputs, {}, builder) => {
  const { index, weight, bindMatrix, bindMatrixInverse, boneMatrices } = inputs;
  const boneMatX = boneMatrices.element(index.x);
  const boneMatY = boneMatrices.element(index.y);
  const boneMatZ = boneMatrices.element(index.z);
  const boneMatW = boneMatrices.element(index.w);
  const skinVertex = bindMatrix.mul(positionLocal);
  const skinned = add(
    boneMatX.mul(weight.x).mul(skinVertex),
    boneMatY.mul(weight.y).mul(skinVertex),
    boneMatZ.mul(weight.z).mul(skinVertex),
    boneMatW.mul(weight.w).mul(skinVertex)
  );
  const skinPosition = bindMatrixInverse.mul(skinned).xyz;
  let skinMatrix = add(
    weight.x.mul(boneMatX),
    weight.y.mul(boneMatY),
    weight.z.mul(boneMatZ),
    weight.w.mul(boneMatW)
  );
  skinMatrix = bindMatrixInverse.mul(skinMatrix).mul(bindMatrix);
  const skinNormal = skinMatrix.transformDirection(normalLocal).xyz;
  positionLocal.assign(skinPosition).build(builder);
  normalLocal.assign(skinNormal).build(builder);
  if (builder.hasGeometryAttribute("tangent")) {
    tangentLocal.assign(skinNormal).build(builder);
  }
});
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = uniform(skinnedMesh.bindMatrix, "mat4");
    this.bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, "mat4");
    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  }
  generate(builder) {
    Skinning.call({
      index: this.skinIndexNode,
      weight: this.skinWeightNode,
      bindMatrix: this.bindMatrixNode,
      bindMatrixInverse: this.bindMatrixInverseNode,
      boneMatrices: this.boneMatricesNode
    }, {}, builder);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
};
var SkinningNode_default = SkinningNode;
var skinning = nodeProxy(SkinningNode);
addNodeClass(SkinningNode);

// node_modules/three/examples/jsm/nodes/accessors/ReflectVectorNode.js
var ReflectVectorNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  construct() {
    const reflectView = positionViewDirection.negate().reflect(transformedNormalView);
    return reflectView.transformDirection(cameraViewMatrix);
  }
};
var ReflectVectorNode_default = ReflectVectorNode;
var reflectVector = nodeImmutable(ReflectVectorNode);
addNodeClass(ReflectVectorNode);

// node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isCubeTextureNode = true;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return reflectVector;
  }
  generate(builder, output) {
    const { uvNode, levelNode } = builder.getNodeProperties(this);
    const texture2 = this.value;
    if (!texture2 || texture2.isCubeTexture !== true) {
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    }
    const textureProperty = UniformNode_default.prototype.generate.call(this, builder, "cubeTexture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const cubeUV = vec3(uvNode.x.negate(), uvNode.yz);
        const uvSnippet = cubeUV.build(builder, "vec3");
        const nodeVar = builder.getVarFromNode(this, "vec4");
        propertyName = builder.getPropertyName(nodeVar);
        let snippet = null;
        if (levelNode && levelNode.isNode === true) {
          const levelSnippet = levelNode.build(builder, "float");
          snippet = builder.getTextureLevel(this, textureProperty, uvSnippet, levelSnippet);
        } else {
          snippet = builder.getTexture(this, textureProperty, uvSnippet);
        }
        builder.addLineFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
      }
      return builder.format(propertyName, "vec4", output);
    }
  }
};
var CubeTextureNode_default = CubeTextureNode;
var cubeTexture = nodeProxy(CubeTextureNode);
addNodeElement("cubeTexture", cubeTexture);
addNodeClass(CubeTextureNode);

// node_modules/three/examples/jsm/nodes/lighting/LightingNode.js
var LightingNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var LightingNode_default = LightingNode;
addNodeClass(LightingNode);

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    if (this.elseNode !== null) {
      const elseType = this.elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const context2 = { tempWrite: false };
    const { ifNode, elseNode } = this;
    const needsProperty = ifNode.getNodeType(builder) !== "void" || elseNode && elseNode.getNodeType(builder) !== "void";
    const nodeProperty = needsProperty ? property(type).build(builder) : "";
    const nodeSnippet = context(
      this.condNode
      /*, context*/
    ).build(builder, "bool");
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = context(this.ifNode, context2).build(builder, type);
    ifSnippet = needsProperty ? nodeProperty + " = " + ifSnippet + ";" : ifSnippet;
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = context(elseNode, context2).build(builder, type);
      elseSnippet = nodeProperty ? nodeProperty + " = " + elseSnippet + ";" : elseSnippet;
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return nodeProperty;
  }
};
var CondNode_default = CondNode;
var cond = nodeProxy(CondNode);
addNodeElement("cond", cond);
addNodeClass(CondNode);

// node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js
var depthMaterial = null;
var AnalyticLightNode = class extends LightingNode_default {
  constructor(light = null) {
    super();
    this.updateType = NodeUpdateType.FRAME;
    this.light = light;
    this.rtt = null;
    this.shadowNode = null;
    this.color = new Color();
    this.colorNode = uniform(this.color);
  }
  getHash() {
    return this.light.uuid;
  }
  constructShadow(builder) {
    let shadowNode = this.shadowNode;
    if (shadowNode === null) {
      if (depthMaterial === null)
        depthMaterial = builder.createNodeMaterial("MeshBasicNodeMaterial");
      const shadow = this.light.shadow;
      const rtt = builder.getRenderTarget(shadow.mapSize.width, shadow.mapSize.height);
      const depthTexture = new DepthTexture();
      depthTexture.minFilter = NearestFilter;
      depthTexture.magFilter = NearestFilter;
      depthTexture.image.width = shadow.mapSize.width;
      depthTexture.image.height = shadow.mapSize.height;
      rtt.depthTexture = depthTexture;
      shadow.camera.updateProjectionMatrix();
      const bias = reference("bias", "float", shadow);
      let shadowCoord = uniform(shadow.matrix).mul(positionWorld);
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      shadowCoord = vec3(
        shadowCoord.x,
        shadowCoord.y.oneMinus(),
        shadowCoord.z
      );
      let depth = texture(depthTexture, shadowCoord.xy);
      depth = depth.mul(0.5).add(0.5).add(bias);
      shadowNode = cond(shadowCoord.z.lessThan(depth).or(
        shadowCoord.y.lessThan(1e-6)
        /*@TODO: find the cause and remove it soon */
      ), 1, 0);
      this.rtt = rtt;
      this.colorNode = this.colorNode.mul(shadowNode);
      this.shadowNode = shadowNode;
      this.updateBeforeType = NodeUpdateType.RENDER;
    }
  }
  construct(builder) {
    if (this.light.castShadow)
      this.constructShadow(builder);
  }
  updateShadow(frame) {
    const { rtt, light } = this;
    const { renderer, scene } = frame;
    scene.overrideMaterial = depthMaterial;
    rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);
    light.shadow.updateMatrices(light);
    renderer.setRenderTarget(rtt);
    renderer.render(scene, light.shadow.camera);
    renderer.setRenderTarget(null);
    scene.overrideMaterial = null;
  }
  updateBefore(frame) {
    const { light } = this;
    if (light.castShadow)
      this.updateShadow(frame);
  }
  update() {
    const { light } = this;
    this.color.copy(light.color).multiplyScalar(light.intensity);
  }
};
var AnalyticLightNode_default = AnalyticLightNode;
addNodeClass(AnalyticLightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightsNode.js
var LightNodes = /* @__PURE__ */ new WeakMap();
var sortLights = (lights2) => {
  return lights2.sort((a, b) => a.id - b.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes = []) {
    super("vec3");
    this.lightNodes = lightNodes;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  construct(builder) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
  }
  getHash(builder) {
    if (this._hash === null) {
      let hash = "";
      const lightNodes = this.lightNodes;
      for (const lightNode of lightNodes) {
        hash += lightNode.getHash(builder) + " ";
      }
      this._hash = hash;
    }
    return this._hash;
  }
  getLightNodeByHash(hash) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      if (lightNode.light.uuid === hash) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights2 = []) {
    const lightNodes = [];
    lights2 = sortLights(lights2);
    for (const light of lights2) {
      let lightNode = this.getLightNodeByHash(light.uuid);
      if (lightNode === null) {
        const lightClass = light.constructor;
        const lightNodeClass = LightNodes.has(lightClass) ? LightNodes.get(lightClass) : AnalyticLightNode_default;
        lightNode = nodeObject(new lightNodeClass(light));
      }
      lightNodes.push(lightNode);
    }
    this.lightNodes = lightNodes;
    this._hash = null;
    return this;
  }
};
var LightsNode_default = LightsNode;
var lights = (lights2) => nodeObject(new LightsNode().fromLights(lights2));
var lightsWithoutWrap = nodeProxy(LightsNode);
function addLightNode(lightClass, lightNodeClass) {
  if (LightNodes.has(lightClass))
    throw new Error(`Redefinition of light node ${lightNodeClass.name}`);
  if (typeof lightClass !== "function" || !lightClass.name)
    throw new Error(`Light ${lightClass.name} is not a class`);
  if (typeof lightNodeClass !== "function" || !lightNodeClass.name)
    throw new Error(`Light node ${lightNodeClass.name} is not a class`);
  LightNodes.set(lightClass, lightNodeClass);
}

// node_modules/three/examples/jsm/nodes/lighting/AONode.js
var AONode = class extends LightingNode_default {
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  construct(builder) {
    const aoIntensity = 1;
    const aoNode = this.aoNode.sub(1).mul(aoIntensity).add(1);
    builder.context.ambientOcclusion.mulAssign(aoNode);
  }
};
var AONode_default = AONode;
addNodeClass(AONode);

// node_modules/three/examples/jsm/nodes/utils/EquirectUVNode.js
var EquirectUVNode = class extends TempNode_default {
  constructor(dirNode = positionWorldDirection) {
    super("vec2");
    this.dirNode = dirNode;
  }
  construct() {
    const dir = this.dirNode;
    const u = dir.z.atan2(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
    const v = dir.y.negate().clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return vec2(u, v);
  }
};
var EquirectUVNode_default = EquirectUVNode;
var equirectUV = nodeProxy(EquirectUVNode);
addNodeClass(EquirectUVNode);

// node_modules/three/examples/jsm/nodes/utils/MaxMipLevelNode.js
var MaxMipLevelNode = class extends UniformNode_default {
  constructor(textureNode) {
    super(0);
    this.textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const texture2 = this.texture;
    const images = texture2.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture2.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var MaxMipLevelNode_default = MaxMipLevelNode;
var maxMipLevel = nodeProxy(MaxMipLevelNode);
addNodeClass(MaxMipLevelNode);

// node_modules/three/examples/jsm/nodes/utils/SpecularMIPLevelNode.js
var SpecularMIPLevelNode = class extends Node_default {
  constructor(textureNode, roughnessNode = null) {
    super("float");
    this.textureNode = textureNode;
    this.roughnessNode = roughnessNode;
  }
  construct() {
    const { textureNode, roughnessNode } = this;
    const maxMIPLevelScalar = maxMipLevel(textureNode);
    const sigma = roughnessNode.mul(roughnessNode).mul(Math.PI).div(roughnessNode.add(1));
    const desiredMIPLevel = maxMIPLevelScalar.add(sigma.log2());
    return desiredMIPLevel.clamp(0, maxMIPLevelScalar);
  }
};
var SpecularMIPLevelNode_default = SpecularMIPLevelNode;
var specularMIPLevel = nodeProxy(SpecularMIPLevelNode);
addNodeClass(SpecularMIPLevelNode);

// node_modules/three/examples/jsm/nodes/lighting/EnvironmentNode.js
var EnvironmentNode = class extends LightingNode_default {
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  construct(builder) {
    let envNode = this.envNode;
    const properties = builder.getNodeProperties(this);
    if (envNode.isTextureNode && envNode.value.isCubeTexture !== true) {
      const texture2 = envNode.value;
      const renderer = builder.renderer;
      const cubeRTT = builder.getCubeRenderTarget(512).fromEquirectangularTexture(renderer, texture2);
      envNode = cubeTexture(cubeRTT.texture);
    }
    let reflectVec;
    let radianceTextureUVNode;
    let irradianceTextureUVNode;
    const radianceContext = context(envNode, {
      getUVNode: (textureNode) => {
        let node = null;
        if (reflectVec === void 0) {
          reflectVec = positionViewDirection.negate().reflect(transformedNormalView);
          reflectVec = roughness.mul(roughness).mix(reflectVec, transformedNormalView).normalize();
          reflectVec = reflectVec.transformDirection(cameraViewMatrix);
        }
        if (textureNode.isCubeTextureNode) {
          node = reflectVec;
        } else if (textureNode.isTextureNode) {
          if (radianceTextureUVNode === void 0) {
            radianceTextureUVNode = equirectUV(reflectVec);
          }
          node = radianceTextureUVNode;
        }
        return node;
      },
      getSamplerLevelNode: () => {
        return roughness;
      },
      getMIPLevelAlgorithmNode: (textureNode, levelNode) => {
        return specularMIPLevel(textureNode, levelNode);
      }
    });
    const irradianceContext = context(envNode, {
      getUVNode: (textureNode) => {
        let node = null;
        if (textureNode.isCubeTextureNode) {
          node = transformedNormalWorld;
        } else if (textureNode.isTextureNode) {
          if (irradianceTextureUVNode === void 0) {
            irradianceTextureUVNode = equirectUV(transformedNormalWorld);
            irradianceTextureUVNode = vec2(irradianceTextureUVNode.x, irradianceTextureUVNode.y.oneMinus());
          }
          node = irradianceTextureUVNode;
        }
        return node;
      },
      getSamplerLevelNode: () => {
        return float(1);
      },
      getMIPLevelAlgorithmNode: (textureNode, levelNode) => {
        return specularMIPLevel(textureNode, levelNode);
      }
    });
    const isolateRadianceFlowContext = cache(radianceContext);
    const intensity = reference("envMapIntensity", "float", builder.material);
    builder.context.radiance.addAssign(isolateRadianceFlowContext.mul(intensity));
    builder.context.iblIrradiance.addAssign(irradianceContext.mul(Math.PI).mul(intensity));
    properties.radianceContext = isolateRadianceFlowContext;
    properties.irradianceContext = irradianceContext;
  }
};
var EnvironmentNode_default = EnvironmentNode;
addNodeClass(EnvironmentNode);

// node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js
var NodeMaterials = /* @__PURE__ */ new Map();
var NodeMaterial = class extends ShaderMaterial {
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.type = this.constructor.name;
    this.lights = true;
    this.normals = true;
    this.lightsNode = null;
    this.envNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.positionNode = null;
  }
  customProgramCacheKey() {
    return getCacheKey(this);
  }
  build(builder) {
    this.construct(builder);
  }
  construct(builder) {
    builder.addStack();
    builder.stack.outputNode = this.constructPosition(builder);
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    if (this.normals === true)
      this.constructNormal(builder);
    this.constructDiffuseColor(builder);
    this.constructVariants(builder);
    const outgoingLightNode = this.constructLighting(builder);
    builder.stack.outputNode = this.constructOutput(builder, outgoingLightNode, diffuseColor.a);
    builder.addFlow("fragment", builder.removeStack());
  }
  constructPosition(builder) {
    const object = builder.object;
    let vertex = positionLocal;
    if (this.positionNode !== null) {
      vertex = vertex.bypass(positionLocal.assign(this.positionNode));
    }
    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable("instance") === true) {
      vertex = vertex.bypass(instance(object));
    }
    if (object.isSkinnedMesh === true) {
      vertex = vertex.bypass(skinning(object));
    }
    builder.context.vertex = vertex;
    return modelViewProjection();
  }
  constructDiffuseColor({ stack: stack2, geometry }) {
    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = vec4(colorNode.xyz.mul(attribute("color")), colorNode.a);
    }
    stack2.assign(diffuseColor, colorNode);
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    stack2.assign(diffuseColor.a, diffuseColor.a.mul(opacityNode));
    if (this.alphaTestNode || this.alphaTest > 0) {
      const alphaTestNode = this.alphaTestNode ? float(this.alphaTestNode) : materialAlphaTest;
      stack2.add(diffuseColor.a.lessThanEqual(alphaTestNode).discard());
    }
  }
  constructVariants() {
  }
  constructNormal({ stack: stack2 }) {
    const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;
    stack2.assign(transformedNormalView, normalNode);
    return normalNode;
  }
  getEnvNode(builder) {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);
    } else if (builder.environmentNode) {
      node = builder.environmentNode;
    }
    return node;
  }
  constructLights(builder) {
    const envNode = this.getEnvNode(builder);
    const materialLightsNode = [];
    if (envNode) {
      materialLightsNode.push(new EnvironmentNode_default(envNode));
    }
    if (builder.material.aoMap) {
      materialLightsNode.push(new AONode_default(texture(builder.material.aoMap)));
    }
    let lightsNode = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsNode = lightsWithoutWrap([...lightsNode.lightNodes, ...materialLightsNode]);
    }
    return lightsNode;
  }
  constructLightingModel() {
  }
  constructLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights2 = this.lights === true || this.lightsNode !== null;
    const lightsNode = lights2 ? this.constructLights(builder) : null;
    const lightingModelNode = lightsNode ? this.constructLightingModel(builder) : null;
    let outgoingLightNode = diffuseColor.rgb;
    if (lightsNode && lightsNode.hasLight !== false) {
      outgoingLightNode = lightsNode.lightingContext(lightingModelNode, backdropNode, backdropAlphaNode);
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
    }
    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      outgoingLightNode = outgoingLightNode.add(emissiveNode ? vec3(emissiveNode) : materialEmissive);
    }
    return outgoingLightNode;
  }
  constructOutput(builder, outgoingLight, opacity) {
    const renderer = builder.renderer;
    const toneMappingNode = builder.toneMappingNode;
    if (toneMappingNode) {
      outgoingLight = toneMappingNode.context({ color: outgoingLight });
    }
    let outputNode = vec4(outgoingLight, opacity);
    const renderTarget = renderer.getRenderTarget();
    let outputColorSpace;
    if (renderTarget !== null) {
      outputColorSpace = renderTarget.texture.colorSpace;
    } else {
      outputColorSpace = renderer.outputColorSpace;
    }
    if (outputColorSpace !== NoColorSpace)
      outputNode = outputNode.colorSpace(outputColorSpace);
    const fogNode = builder.fogNode;
    if (fogNode)
      outputNode = vec4(fogNode.mixAssign(outputNode.rgb), outputNode.a);
    return outputNode;
  }
  setDefaultValues(material) {
    for (const property2 in material) {
      const value = material[property2];
      if (this[property2] === void 0) {
        this[property2] = value;
        if (value && value.clone)
          this[property2] = value.clone();
      }
    }
    Object.assign(this.defines, material.defines);
    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
    for (const key in descriptors) {
      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) {
        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeChildren = getNodeChildren(this);
    data.inputNodes = {};
    for (const { property: property2, childNode } of nodeChildren) {
      data.inputNodes[property2] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
  static fromMaterial(material) {
    if (material.isNodeMaterial === true) {
      return material;
    }
    const type = material.type.replace("Material", "NodeMaterial");
    const nodeMaterial = createNodeMaterialFromType(type);
    if (nodeMaterial === void 0) {
      throw new Error(`NodeMaterial: Material "${material.type}" is not compatible.`);
    }
    for (const key in material) {
      nodeMaterial[key] = material[key];
    }
    return nodeMaterial;
  }
};
var NodeMaterial_default = NodeMaterial;
function addNodeMaterial(nodeMaterial) {
  if (typeof nodeMaterial !== "function" || !nodeMaterial.name)
    throw new Error(`Node material ${nodeMaterial.name} is not a class`);
  if (NodeMaterials.has(nodeMaterial.name))
    throw new Error(`Redefinition of node material ${nodeMaterial.name}`);
  NodeMaterials.set(nodeMaterial.name, nodeMaterial);
}
function createNodeMaterialFromType(type) {
  const Material2 = NodeMaterials.get(type);
  if (Material2 !== void 0) {
    return new Material2();
  }
}
addNodeMaterial(NodeMaterial);

// node_modules/three/examples/jsm/nodes/code/ExpressionNode.js
var ExpressionNode = class extends Node_default {
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet);
    } else {
      return builder.format(`( ${snippet} )`, type, output);
    }
  }
};
var ExpressionNode_default = ExpressionNode;
var expression = nodeProxy(ExpressionNode);
addNodeClass(ExpressionNode);

// node_modules/three/examples/jsm/nodes/utils/LoopNode.js
var LoopNode = class extends Node_default {
  constructor(params = []) {
    super();
    this.params = params;
  }
  getVarName(index) {
    return String.fromCharCode("i".charCodeAt() + index);
  }
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0)
      return properties;
    const inputs = {};
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      const prop = this.getVarName(i);
      inputs[prop] = expression(prop, "int");
    }
    properties.returnsNode = this.params[this.params.length - 1].call(inputs, builder.addStack(), builder);
    properties.stackNode = builder.removeStack();
    return properties;
  }
  getNodeType(builder) {
    const { returnsNode } = this.getProperties(builder);
    return returnsNode ? returnsNode.getNodeType(builder) : "void";
  }
  construct(builder) {
    this.getProperties(builder);
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const context2 = { tempWrite: false };
    const params = this.params;
    const stackNode = properties.stackNode;
    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : "";
    for (let i = 0, l = params.length - 1; i < l; i++) {
      const param = params[i];
      const property2 = this.getVarName(i);
      let start = null, end = null, direction = null;
      if (param.isNode) {
        start = "0";
        end = param.generate(builder, "int");
        direction = "forward";
      } else {
        start = param.start;
        end = param.end;
        direction = param.direction;
        if (typeof start === "number")
          start = start.toString();
        else if (start && start.isNode)
          start = start.generate(builder, "int");
        if (typeof end === "number")
          end = end.toString();
        else if (end && end.isNode)
          end = end.generate(builder, "int");
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          direction = "backwards";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          direction = "forward";
        }
        if (direction === void 0) {
          if (Number(start) > Number(end)) {
            direction = "backwards";
          } else {
            direction = "forward";
          }
        }
      }
      const internalParam = { start, end, direction };
      const startSnippet = internalParam.start;
      const endSnippet = internalParam.end;
      let declarationSnippet = "";
      let conditionalSnippet = "";
      let updateSnippet = "";
      declarationSnippet += builder.getVar("int", property2) + " = " + startSnippet;
      if (internalParam.direction === "backwards") {
        conditionalSnippet += property2 + " >= " + endSnippet;
        updateSnippet += property2 + " --";
      } else {
        conditionalSnippet += property2 + " < " + endSnippet;
        updateSnippet += property2 + " ++";
      }
      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + forSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = context(stackNode, context2).build(builder, "void");
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
    return returnsSnippet;
  }
};
var LoopNode_default = LoopNode;
var loop = (...params) => nodeObject(new LoopNode(nodeArray(params, "int")));
addNodeElement("loop", (returns, ...params) => bypass(returns, loop(...params)));
addNodeClass(LoopNode);

// node_modules/three/examples/jsm/nodes/core/StackNode.js
var StackNode = class extends Node_default {
  constructor(parent = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent;
    this._currentCond = null;
    this.isStackNode = true;
  }
  getNodeType(builder) {
    return this.outputNode ? this.outputNode.getNodeType(builder) : "void";
  }
  add(node) {
    this.nodes.push(bypass(expression(), node));
    return this;
  }
  if(boolNode, method) {
    const methodNode = shader(method);
    this._currentCond = cond(boolNode, methodNode);
    return this.add(this._currentCond);
  }
  elseif(boolNode, method) {
    const methodNode = shader(method);
    const ifNode = cond(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  else(method) {
    this._currentCond.elseNode = shader(method);
    return this;
  }
  assign(targetNode, sourceValue) {
    return this.add(assign(targetNode, sourceValue));
  }
  loop(...params) {
    return this.add(loop(...params));
  }
  build(builder, ...params) {
    for (const node of this.nodes) {
      node.build(builder);
    }
    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);
  }
};
var StackNode_default = StackNode;
var stack = nodeProxy(StackNode);
addNodeClass(StackNode);

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var typeFromLength = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]);
var typeFromArray = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]);
var isNonPaddingElementArray = /* @__PURE__ */ new Set([Int32Array, Uint32Array, Float32Array]);
var toFloat = (value) => {
  value = Number(value);
  return value + (value % 1 ? "" : ".0");
};
var NodeBuilder = class {
  constructor(object, renderer, parser) {
    this.object = object;
    this.material = object && (object.material || null);
    this.geometry = object && (object.geometry || null);
    this.renderer = renderer;
    this.parser = parser;
    this.nodes = [];
    this.updateNodes = [];
    this.updateBeforeNodes = [];
    this.hashNodes = {};
    this.lightsNode = null;
    this.environmentNode = null;
    this.fogNode = null;
    this.toneMappingNode = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: [] };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.codes = { vertex: [], fragment: [], compute: [] };
    this.bindings = { vertex: [], fragment: [], compute: [] };
    this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };
    this.bindingsArray = null;
    this.attributes = [];
    this.bufferAttributes = [];
    this.varyings = [];
    this.vars = { vertex: [], fragment: [], compute: [] };
    this.flow = { code: "" };
    this.chaining = [];
    this.stack = stack();
    this.tab = "	";
    this.context = {
      keywords: new NodeKeywords_default(),
      material: this.material,
      getMIPLevelAlgorithmNode: (textureNode, levelNode) => levelNode.mul(maxMipLevel(textureNode))
    };
    this.cache = new NodeCache_default();
    this.globalCache = this.cache;
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
  }
  getBindings() {
    let bindingsArray = this.bindingsArray;
    if (bindingsArray === null) {
      const bindings = this.bindings;
      this.bindingsArray = bindingsArray = this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute;
    }
    return bindingsArray;
  }
  setHashNode(node, hash) {
    this.hashNodes[hash] = node;
  }
  addNode(node) {
    if (this.nodes.indexOf(node) === -1) {
      const updateType = node.getUpdateType();
      const updateBeforeType = node.getUpdateBeforeType();
      if (updateType !== NodeUpdateType.NONE) {
        this.updateNodes.push(node);
      }
      if (updateBeforeType !== NodeUpdateType.NONE) {
        this.updateBeforeNodes.push(node);
      }
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(node) {
    this.chaining.push(node);
  }
  removeChain(node) {
    const lastChain = this.chaining.pop();
    if (lastChain !== node) {
      throw new Error("NodeBuilder: Invalid node chaining!");
    }
  }
  getMethod(method) {
    return method;
  }
  getNodeFromHash(hash) {
    return this.hashNodes[hash];
  }
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  setContext(context2) {
    this.context = context2;
  }
  getContext() {
    return this.context;
  }
  setCache(cache2) {
    this.cache = cache2;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return false;
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return false;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  // @TODO: rename to .generateConst()
  getConst(type, value = null) {
    if (value === null) {
      if (type === "float" || type === "int" || type === "uint")
        value = 0;
      else if (type === "bool")
        value = false;
      else if (type === "color")
        value = new Color();
      else if (type === "vec2")
        value = new Vector2();
      else if (type === "vec3")
        value = new Vector3();
      else if (type === "vec4")
        value = new Vector4();
    }
    if (type === "float")
      return toFloat(value);
    if (type === "int")
      return `${Math.round(value)}`;
    if (type === "uint")
      return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool")
      return value ? "true" : "false";
    if (type === "color")
      return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const getConst = (value2) => this.getConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;
    } else if (typeLength === 4) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;
    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {
      return `${this.getType(type)}( ${value.elements.map(getConst).join(", ")} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
  }
  getType(type) {
    return type;
  }
  generateMethod(method) {
    return method;
  }
  hasGeometryAttribute(name) {
    return this.geometry && this.geometry.getAttribute(name) !== void 0;
  }
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute_default(name, type);
    attributes.push(attribute2);
    return attribute2;
  }
  getPropertyName(node) {
    return node.name;
  }
  isVector(type) {
    return /vec\d/.test(type);
  }
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  isReference(type) {
    return type === "void" || type === "property" || type === "sampler" || type === "texture" || type === "cubeTexture";
  }
  /** @deprecated, r152 */
  getTextureEncodingFromMap(map) {
    console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.");
    return this.getTextureColorSpaceFromMap(map) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  getTextureColorSpaceFromMap(map) {
    let colorSpace2;
    if (map && map.isTexture) {
      colorSpace2 = map.colorSpace;
    } else if (map && map.isWebGLRenderTarget) {
      colorSpace2 = map.texture.colorSpace;
    } else {
      colorSpace2 = NoColorSpace;
    }
    return colorSpace2;
  }
  getComponentType(type) {
    type = this.getVectorType(type);
    if (type === "float" || type === "bool" || type === "int" || type === "uint")
      return type;
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null)
      return null;
    if (componentType[1] === "b")
      return "bool";
    if (componentType[1] === "i")
      return "int";
    if (componentType[1] === "u")
      return "uint";
    return "float";
  }
  getVectorType(type) {
    if (type === "color")
      return "vec3";
    if (type === "texture")
      return "vec4";
    return type;
  }
  getTypeFromLength(length2, componentType = "float") {
    if (length2 === 1)
      return componentType;
    const baseType = typeFromLength.get(length2);
    const prefix = componentType === "float" ? "" : componentType[0];
    return prefix + baseType;
  }
  getTypeFromArray(array) {
    return typeFromArray.get(array.constructor);
  }
  getTypeFromAttribute(attribute2) {
    let dataAttribute = attribute2;
    if (attribute2.isInterleavedBufferAttribute)
      dataAttribute = attribute2.data;
    const array = dataAttribute.array;
    const itemSize = isNonPaddingElementArray.has(array.constructor) ? attribute2.itemSize : dataAttribute.stride || attribute2.itemSize;
    const normalized = attribute2.normalized;
    let arrayType;
    if (!(attribute2 instanceof Float16BufferAttribute) && normalized !== true) {
      arrayType = this.getTypeFromArray(array);
    }
    return this.getTypeFromLength(itemSize, arrayType);
  }
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null)
      return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint")
      return 1;
    if (/mat3/.test(type) === true)
      return 9;
    if (/mat4/.test(type) === true)
      return 16;
    return 0;
  }
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  changeComponentType(type, newComponentType) {
    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
  }
  getIntegerType(type) {
    const componentType = this.getComponentType(type);
    if (componentType === "int" || componentType === "uint")
      return type;
    return this.changeComponentType(type, "int");
  }
  addStack() {
    this.stack = stack(this.stack);
    return this.stack;
  }
  removeStack() {
    const currentStack = this.stack;
    this.stack = currentStack.parent;
    return currentStack;
  }
  getDataFromNode(node, shaderStage = this.shaderStage) {
    const cache2 = node.isGlobal(this) ? this.globalCache : this.cache;
    let nodeData = cache2.getNodeData(node);
    if (nodeData === void 0) {
      nodeData = { vertex: {}, fragment: {}, compute: {} };
      cache2.setNodeData(node, nodeData);
    }
    return shaderStage !== null ? nodeData[shaderStage] : nodeData;
  }
  getNodeProperties(node, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    return nodeData.properties || (nodeData.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(node, type) {
    const nodeData = this.getDataFromNode(node);
    let bufferAttribute2 = nodeData.bufferAttribute;
    if (bufferAttribute2 === void 0) {
      const index = this.uniforms.index++;
      bufferAttribute2 = new NodeAttribute_default("nodeAttribute" + index, type, node);
      this.bufferAttributes.push(bufferAttribute2);
      nodeData.bufferAttribute = bufferAttribute2;
    }
    return bufferAttribute2;
  }
  getUniformFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index = this.uniforms.index++;
      nodeUniform = new NodeUniform_default("nodeUniform" + index, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  getVarFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeVar = nodeData.variable;
    if (nodeVar === void 0) {
      const vars = this.vars[shaderStage];
      const index = vars.length;
      nodeVar = new NodeVar_default("nodeVar" + index, type);
      vars.push(nodeVar);
      nodeData.variable = nodeVar;
    }
    return nodeVar;
  }
  getVaryingFromNode(node, type) {
    const nodeData = this.getDataFromNode(node, null);
    let nodeVarying = nodeData.varying;
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index = varyings.length;
      nodeVarying = new NodeVarying_default("nodeVarying" + index, type);
      varyings.push(nodeVarying);
      nodeData.varying = nodeVarying;
    }
    return nodeVarying;
  }
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage];
      const index = codes.length;
      nodeCode = new NodeCode_default("nodeCode" + index, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  addLineFlowCode(code2) {
    if (code2 === "")
      return this;
    code2 = this.tab + code2;
    if (!/;\s*$/.test(code2)) {
      code2 = code2 + ";\n";
    }
    this.flow.code += code2;
    return this;
  }
  addFlowCode(code2) {
    this.flow.code += code2;
    return this;
  }
  addFlowTab() {
    this.tab += "	";
    return this;
  }
  removeFlowTab() {
    this.tab = this.tab.slice(0, -1);
    return this;
  }
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  flowNode(node) {
    const output = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  flowChildNode(node, output = null) {
    const previousFlow = this.flow;
    const flow = {
      code: ""
    };
    this.flow = flow;
    flow.result = node.build(this, output);
    this.flow = previousFlow;
    return flow;
  }
  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
    const previousShaderStage = this.shaderStage;
    this.setShaderStage(shaderStage);
    const flowData = this.flowChildNode(node, output);
    if (propertyName !== null) {
      flowData.code += `${this.tab + propertyName} = ${flowData.result};
`;
    }
    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
    this.setShaderStage(previousShaderStage);
    return flowData;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(type, name) {
    return `${type} ${name}`;
  }
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    for (const variable of vars) {
      snippet += `${this.getVar(variable.type, variable.name)}; `;
    }
    return snippet;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code2 = "";
    for (const nodeCode of codes) {
      code2 += nodeCode.code + "\n";
    }
    return code2;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      if (this.context.vertex && this.context.vertex.isNode) {
        this.flowNodeFromShaderStage("vertex", this.context.vertex);
      }
      for (const shaderStage of shaderStages) {
        this.setShaderStage(shaderStage);
        const flowNodes = this.flowNodes[shaderStage];
        for (const node of flowNodes) {
          if (buildStage === "generate") {
            this.flowNode(node);
          } else {
            node.build(this);
          }
        }
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    return this;
  }
  createNodeMaterial(type) {
    return createNodeMaterialFromType(type);
  }
  format(snippet, fromType, toType) {
    fromType = this.getVectorType(fromType);
    toType = this.getVectorType(toType);
    if (fromType === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      return this.format(`${snippet}.${"xyz".slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
    }
    if (toTypeLength === 4) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec2")}, 0.0 )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  getSignature() {
    return `// Three.js r${REVISION} - NodeMaterial System
`;
  }
};
var NodeBuilder_default = NodeBuilder;

// node_modules/three/examples/jsm/nodes/core/NodeFrame.js
var NodeFrame = class {
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.renderId = 0;
    this.startTime = null;
    this.frameMap = /* @__PURE__ */ new WeakMap();
    this.frameBeforeMap = /* @__PURE__ */ new WeakMap();
    this.renderMap = /* @__PURE__ */ new WeakMap();
    this.renderBeforeMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
    this.scene = null;
  }
  updateBeforeNode(node) {
    const updateType = node.getUpdateBeforeType();
    if (updateType === NodeUpdateType.FRAME) {
      if (this.frameBeforeMap.get(node) !== this.frameId) {
        this.frameBeforeMap.set(node, this.frameId);
        node.updateBefore(this);
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      if (this.renderBeforeMap.get(node) !== this.renderId || this.frameBeforeMap.get(node) !== this.frameId) {
        this.renderBeforeMap.set(node, this.renderId);
        this.frameBeforeMap.set(node, this.frameId);
        node.updateBefore(this);
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateBefore(this);
    }
  }
  updateNode(node) {
    const updateType = node.getUpdateType();
    if (updateType === NodeUpdateType.FRAME) {
      if (this.frameMap.get(node) !== this.frameId) {
        this.frameMap.set(node, this.frameId);
        node.update(this);
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      if (this.renderMap.get(node) !== this.renderId || this.frameMap.get(node) !== this.frameId) {
        this.renderMap.set(node, this.renderId);
        this.frameMap.set(node, this.frameId);
        node.update(this);
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.update(this);
    }
  }
  update() {
    this.frameId++;
    if (this.lastTime === void 0)
      this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFrame_default = NodeFrame;

// node_modules/three/examples/jsm/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type, name, count = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var NodeFunctionInput_default = NodeFunctionInput;

// node_modules/three/examples/jsm/nodes/utils/DiscardNode.js
var discardExpression;
var DiscardNode = class extends CondNode_default {
  constructor(condNode) {
    discardExpression = discardExpression || expression("discard");
    super(condNode, discardExpression);
  }
};
var DiscardNode_default = DiscardNode;
var discard = nodeProxy(DiscardNode);
addNodeElement("discard", discard);
addNodeClass(DiscardNode);

// node_modules/three/examples/jsm/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  construct() {
    const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
    const y = positionViewDirection.cross(x);
    return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5);
  }
};
var MatcapUVNode_default = MatcapUVNode;
var matcapUV = nodeImmutable(MatcapUVNode);
addNodeClass(MatcapUVNode);

// node_modules/three/examples/jsm/nodes/utils/TimerNode.js
var TimerNode = class extends UniformNode_default {
  constructor(scope = TimerNode.LOCAL, scale = 1, value = 0) {
    super(value);
    this.scope = scope;
    this.scale = scale;
    this.updateType = NodeUpdateType.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else if (scope === TimerNode.FRAME) {
      this.value = frame.frameId;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
TimerNode.LOCAL = "local";
TimerNode.GLOBAL = "global";
TimerNode.DELTA = "delta";
TimerNode.FRAME = "frame";
var TimerNode_default = TimerNode;
var timerLocal = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.LOCAL, timeScale, value));
var timerGlobal = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.GLOBAL, timeScale, value));
var timerDelta = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.DELTA, timeScale, value));
var frameId = nodeImmutable(TimerNode, TimerNode.FRAME);
addNodeClass(TimerNode);

// node_modules/three/examples/jsm/nodes/utils/OscNode.js
var OscNode = class extends Node_default {
  constructor(method = OscNode.SINE, timeNode = timerLocal()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  construct() {
    const method = this.method;
    const timeNode = nodeObject(this.timeNode);
    let outputNode = null;
    if (method === OscNode.SINE) {
      outputNode = timeNode.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
    } else if (method === OscNode.SQUARE) {
      outputNode = timeNode.fract().round();
    } else if (method === OscNode.TRIANGLE) {
      outputNode = timeNode.add(0.5).fract().mul(2).sub(1).abs();
    } else if (method === OscNode.SAWTOOTH) {
      outputNode = timeNode.fract();
    }
    return outputNode;
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
OscNode.SINE = "sine";
OscNode.SQUARE = "square";
OscNode.TRIANGLE = "triangle";
OscNode.SAWTOOTH = "sawtooth";
var OscNode_default = OscNode;
var oscSine = nodeProxy(OscNode, OscNode.SINE);
var oscSquare = nodeProxy(OscNode, OscNode.SQUARE);
var oscTriangle = nodeProxy(OscNode, OscNode.TRIANGLE);
var oscSawtooth = nodeProxy(OscNode, OscNode.SAWTOOTH);
addNodeClass(OscNode);

// node_modules/three/examples/jsm/nodes/utils/PackingNode.js
var PackingNode = class extends TempNode_default {
  constructor(scope, node) {
    super();
    this.scope = scope;
    this.node = node;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  construct() {
    const { scope, node } = this;
    let result = null;
    if (scope === PackingNode.DIRECTION_TO_COLOR) {
      result = node.mul(0.5).add(0.5);
    } else if (scope === PackingNode.COLOR_TO_DIRECTION) {
      result = node.mul(2).sub(1);
    }
    return result;
  }
};
PackingNode.DIRECTION_TO_COLOR = "directionToColor";
PackingNode.COLOR_TO_DIRECTION = "colorToDirection";
var PackingNode_default = PackingNode;
var directionToColor = nodeProxy(PackingNode, PackingNode.DIRECTION_TO_COLOR);
var colorToDirection = nodeProxy(PackingNode, PackingNode.COLOR_TO_DIRECTION);
addNodeElement("directionToColor", directionToColor);
addNodeElement("colorToDirection", colorToDirection);
addNodeClass(PackingNode);

// node_modules/three/examples/jsm/nodes/utils/RemapNode.js
var RemapNode = class extends Node_default {
  constructor(node, inLowNode, inHighNode, outLowNode, outHighNode) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  construct() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true)
      t = t.clamp();
    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
};
var RemapNode_default = RemapNode;
var remap = nodeProxy(RemapNode, null, null, { doClamp: false });
var remapClamp = nodeProxy(RemapNode);
addNodeElement("remap", remap);
addNodeElement("remapClamp", remapClamp);
addNodeClass(RemapNode);

// node_modules/three/examples/jsm/nodes/utils/RotateUVNode.js
var RotateUVNode = class extends TempNode_default {
  constructor(uvNode, rotationNode, centerNode = vec2(0.5)) {
    super("vec2");
    this.uvNode = uvNode;
    this.rotationNode = rotationNode;
    this.centerNode = centerNode;
  }
  construct() {
    const { uvNode, rotationNode, centerNode } = this;
    const cosAngle = rotationNode.cos();
    const sinAngle = rotationNode.sin();
    const vector = uvNode.sub(centerNode);
    const rotatedVector = vec2(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?
      vec2(cosAngle, sinAngle).dot(vector),
      vec2(sinAngle.negate(), cosAngle).dot(vector)
    );
    return rotatedVector.add(centerNode);
  }
};
var RotateUVNode_default = RotateUVNode;
var rotateUV = nodeProxy(RotateUVNode);
addNodeElement("rotateUV", rotateUV);
addNodeClass(RotateUVNode);

// node_modules/three/examples/jsm/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = uv(), frameNode = float(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  construct() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale = countNode.reciprocal();
    const uvFrameOffset = vec2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale);
  }
};
var SpriteSheetUVNode_default = SpriteSheetUVNode;
var spritesheetUV = nodeProxy(SpriteSheetUVNode);
addNodeClass(SpriteSheetUVNode);

// node_modules/three/examples/jsm/nodes/utils/TriplanarTexturesNode.js
var TriplanarTexturesNode = class extends Node_default {
  constructor(textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionWorld, normalNode = normalWorld) {
    super("vec4");
    this.textureXNode = textureXNode;
    this.textureYNode = textureYNode;
    this.textureZNode = textureZNode;
    this.scaleNode = scaleNode;
    this.positionNode = positionNode;
    this.normalNode = normalNode;
  }
  construct() {
    const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;
    let bf = normalNode.abs().normalize();
    bf = bf.div(bf.dot(vec3(1)));
    const tx = positionNode.yz.mul(scaleNode);
    const ty = positionNode.zx.mul(scaleNode);
    const tz = positionNode.xy.mul(scaleNode);
    const textureX = textureXNode.value;
    const textureY = textureYNode !== null ? textureYNode.value : textureX;
    const textureZ = textureZNode !== null ? textureZNode.value : textureX;
    const cx = texture(textureX, tx).mul(bf.x);
    const cy = texture(textureY, ty).mul(bf.y);
    const cz = texture(textureZ, tz).mul(bf.z);
    return add(cx, cy, cz);
  }
};
var TriplanarTexturesNode_default = TriplanarTexturesNode;
var triplanarTextures = nodeProxy(TriplanarTexturesNode);
var triplanarTexture = (texture2, ...params) => triplanarTextures(texture2, texture2, texture2, ...params);
addNodeElement("triplanarTexture", triplanarTexture);
addNodeClass(TriplanarTexturesNode);

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var PointUVNode_default = PointUVNode;
var pointUV = nodeImmutable(PointUVNode);
addNodeClass(PointUVNode);

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
    this.isStorageBufferNode = true;
  }
  getInputType() {
    return "storageBuffer";
  }
};
var StorageBufferNode_default = StorageBufferNode;
var storage = (value, type, count) => nodeObject(new StorageBufferNode(value, type, count));
addNodeClass(StorageBufferNode);

// node_modules/three/examples/jsm/nodes/accessors/UserDataNode.js
var UserDataNode = class extends ReferenceNode_default {
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  update(frame) {
    this.object = this.userData !== null ? this.userData : frame.object.userData;
    super.update(frame);
  }
};
var UserDataNode_default = UserDataNode;
var userData = (name, inputType, userData2) => nodeObject(new UserDataNode(name, inputType, userData2));
addNodeClass(UserDataNode);

// node_modules/three/examples/jsm/nodes/display/BlendModeNode.js
var BurnNode = new ShaderNode(({ base, blend }) => {
  const fn2 = (c) => blend[c].lessThan(EPSILON).cond(blend[c], base[c].oneMinus().div(blend[c]).oneMinus().max(0));
  return vec3(fn2("x"), fn2("y"), fn2("z"));
});
var DodgeNode = new ShaderNode(({ base, blend }) => {
  const fn2 = (c) => blend[c].equal(1).cond(blend[c], base[c].div(blend[c].oneMinus()).max(0));
  return vec3(fn2("x"), fn2("y"), fn2("z"));
});
var ScreenNode = new ShaderNode(({ base, blend }) => {
  const fn2 = (c) => base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus();
  return vec3(fn2("x"), fn2("y"), fn2("z"));
});
var OverlayNode = new ShaderNode(({ base, blend }) => {
  const fn2 = (c) => base[c].lessThan(0.5).cond(base[c].mul(blend[c], 2), base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus());
  return vec3(fn2("x"), fn2("y"), fn2("z"));
});
var BlendModeNode = class extends TempNode_default {
  constructor(blendMode, baseNode, blendNode) {
    super();
    this.blendMode = blendMode;
    this.baseNode = baseNode;
    this.blendNode = blendNode;
  }
  construct() {
    const { blendMode, baseNode, blendNode } = this;
    const params = { base: baseNode, blend: blendNode };
    let outputNode = null;
    if (blendMode === BlendModeNode.BURN) {
      outputNode = BurnNode.call(params);
    } else if (blendMode === BlendModeNode.DODGE) {
      outputNode = DodgeNode.call(params);
    } else if (blendMode === BlendModeNode.SCREEN) {
      outputNode = ScreenNode.call(params);
    } else if (blendMode === BlendModeNode.OVERLAY) {
      outputNode = OverlayNode.call(params);
    }
    return outputNode;
  }
};
BlendModeNode.BURN = "burn";
BlendModeNode.DODGE = "dodge";
BlendModeNode.SCREEN = "screen";
BlendModeNode.OVERLAY = "overlay";
var BlendModeNode_default = BlendModeNode;
var burn = nodeProxy(BlendModeNode, BlendModeNode.BURN);
var dodge = nodeProxy(BlendModeNode, BlendModeNode.DODGE);
var overlay = nodeProxy(BlendModeNode, BlendModeNode.OVERLAY);
var screen = nodeProxy(BlendModeNode, BlendModeNode.SCREEN);
addNodeElement("burn", burn);
addNodeElement("dodge", dodge);
addNodeElement("overlay", overlay);
addNodeElement("screen", screen);
addNodeClass(BlendModeNode);

// node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js
var saturationNode = new ShaderNode(({ color: color2, adjustment }) => {
  return adjustment.mix(luminance(color2), color2);
});
var vibranceNode = new ShaderNode(({ color: color2, adjustment }) => {
  const average = add(color2.r, color2.g, color2.b).div(3);
  const mx = color2.r.max(color2.g.max(color2.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix(color2, mx, amt);
});
var hueNode = new ShaderNode(({ color: color2, adjustment }) => {
  const RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);
  const YIQtoRGB = mat3(1, 0.9563, 0.621, 1, -0.2721, -0.6474, 1, -1.107, 1.7046);
  const yiq = RGBtoYIQ.mul(color2);
  const hue2 = yiq.z.atan2(yiq.y).add(adjustment);
  const chroma = yiq.yz.length();
  return YIQtoRGB.mul(vec3(yiq.x, chroma.mul(hue2.cos()), chroma.mul(hue2.sin())));
});
var ColorAdjustmentNode = class extends TempNode_default {
  constructor(method, colorNode, adjustmentNode = float(1)) {
    super("vec3");
    this.method = method;
    this.colorNode = colorNode;
    this.adjustmentNode = adjustmentNode;
  }
  construct() {
    const { method, colorNode, adjustmentNode } = this;
    const callParams = { color: colorNode, adjustment: adjustmentNode };
    let outputNode = null;
    if (method === ColorAdjustmentNode.SATURATION) {
      outputNode = saturationNode.call(callParams);
    } else if (method === ColorAdjustmentNode.VIBRANCE) {
      outputNode = vibranceNode.call(callParams);
    } else if (method === ColorAdjustmentNode.HUE) {
      outputNode = hueNode.call(callParams);
    } else {
      console.error(`${this.type}: Method "${this.method}" not supported!`);
    }
    return outputNode;
  }
};
ColorAdjustmentNode.SATURATION = "saturation";
ColorAdjustmentNode.VIBRANCE = "vibrance";
ColorAdjustmentNode.HUE = "hue";
var ColorAdjustmentNode_default = ColorAdjustmentNode;
var saturation = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.SATURATION);
var vibrance = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE);
var hue = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.HUE);
var lumaCoeffs = vec3(0.2125, 0.7154, 0.0721);
var luminance = (color2, luma = lumaCoeffs) => dot(color2, luma);
addNodeElement("saturation", saturation);
addNodeElement("vibrance", vibrance);
addNodeElement("hue", hue);
addNodeClass(ColorAdjustmentNode);

// node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js
var LinearToLinear = new ShaderNode((inputs) => {
  return inputs.value;
});
var LinearTosRGB = new ShaderNode((inputs) => {
  const { value } = inputs;
  const { rgb } = value;
  const a = rgb.pow(0.41666).mul(1.055).sub(0.055);
  const b = rgb.mul(12.92);
  const factor = rgb.lessThanEqual(31308e-7);
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var EncodingLib = {
  LinearToLinear,
  LinearTosRGB
};
var ColorSpaceNode = class extends TempNode_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  fromColorSpace(colorSpace2) {
    let method = null;
    if (colorSpace2 === LinearSRGBColorSpace) {
      method = "Linear";
    } else if (colorSpace2 === SRGBColorSpace) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  fromEncoding(encoding) {
    console.warn("THREE.ColorSpaceNode: Method .fromEncoding renamed to .fromColorSpace.");
    let method = null;
    if (encoding === LinearEncoding) {
      method = "Linear";
    } else if (encoding === sRGBEncoding) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  construct() {
    const { method, node } = this;
    return EncodingLib[method].call({ value: node });
  }
};
ColorSpaceNode.LINEAR_TO_LINEAR = "LinearToLinear";
ColorSpaceNode.LINEAR_TO_SRGB = "LinearTosRGB";
var ColorSpaceNode_default = ColorSpaceNode;
var colorSpace = (node, colorSpace2) => nodeObject(new ColorSpaceNode(null, nodeObject(node)).fromColorSpace(colorSpace2));
addNodeElement("colorSpace", colorSpace);
addNodeClass(ColorSpaceNode);

// node_modules/three/examples/jsm/nodes/display/PosterizeNode.js
var PosterizeNode = class extends TempNode_default {
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  construct() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
};
var PosterizeNode_default = PosterizeNode;
var posterize = nodeProxy(PosterizeNode);
addNodeElement("posterize", posterize);
addNodeClass(PosterizeNode);

// node_modules/three/examples/jsm/nodes/display/ToneMappingNode.js
var LinearToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  return color2.mul(exposure).clamp();
});
var ReinhardToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  return color2.div(color2.add(1)).clamp();
});
var OptimizedCineonToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  color2 = color2.sub(4e-3).max(0);
  const a = color2.mul(color2.mul(6.2).add(0.5));
  const b = color2.mul(color2.mul(6.2).add(1.7)).add(0.06);
  return a.div(b).pow(2.2);
});
var RRTAndODTFit = new ShaderNode(({ color: color2 }) => {
  const a = color2.mul(color2.add(0.0245786)).sub(90537e-9);
  const b = color2.mul(color2.add(0.432951).mul(0.983729)).add(0.238081);
  return a.div(b);
});
var ACESFilmicToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color2 = color2.mul(exposure).div(0.6);
  color2 = ACESInputMat.mul(color2);
  color2 = RRTAndODTFit.call({ color: color2 });
  color2 = ACESOutputMat.mul(color2);
  return color2.clamp();
});
var toneMappingLib = {
  [LinearToneMapping]: LinearToneMappingNode,
  [ReinhardToneMapping]: ReinhardToneMappingNode,
  [CineonToneMapping]: OptimizedCineonToneMappingNode,
  [ACESFilmicToneMapping]: ACESFilmicToneMappingNode
};
var ToneMappingNode = class extends TempNode_default {
  constructor(toneMapping2 = NoToneMapping, exposureNode = float(1), colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  getCacheKey() {
    let cacheKey = super.getCacheKey();
    cacheKey = "{toneMapping:" + this.toneMapping + ",nodes:" + cacheKey + "}";
    return cacheKey;
  }
  construct(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this.toneMapping;
    if (toneMapping2 === NoToneMapping)
      return colorNode;
    const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
    const toneMappingNode = toneMappingLib[toneMapping2];
    let outputNode = null;
    if (toneMappingNode) {
      outputNode = toneMappingNode.call(toneMappingParams);
    } else {
      console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping2);
      outputNode = colorNode;
    }
    return outputNode;
  }
};
var ToneMappingNode_default = ToneMappingNode;
var toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color2)));
addNodeClass(ToneMappingNode);

// node_modules/three/examples/jsm/nodes/display/ViewportNode.js
var resolution;
var ViewportNode = class extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
    this.isViewportNode = true;
  }
  getNodeType() {
    return this.scope === ViewportNode.COORDINATE ? "vec4" : "vec2";
  }
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === ViewportNode.RESOLUTION) {
      updateType = NodeUpdateType.FRAME;
    }
    this.updateType = updateType;
    return updateType;
  }
  update({ renderer }) {
    renderer.getDrawingBufferSize(resolution);
  }
  construct(builder) {
    const scope = this.scope;
    if (scope === ViewportNode.COORDINATE)
      return;
    let output = null;
    if (scope === ViewportNode.RESOLUTION) {
      output = uniform(resolution || (resolution = new Vector2()));
    } else {
      const coordinateNode = vec2(new ViewportNode(ViewportNode.COORDINATE));
      const resolutionNode = new ViewportNode(ViewportNode.RESOLUTION);
      output = coordinateNode.div(resolutionNode);
      let outX = output.x;
      let outY = output.y;
      if (/top/i.test(scope) && builder.isFlipY())
        outY = outY.oneMinus();
      else if (/bottom/i.test(scope) && builder.isFlipY() === false)
        outY = outY.oneMinus();
      if (/right/i.test(scope))
        outX = outX.oneMinus();
      output = vec2(outX, outY);
    }
    return output;
  }
  generate(builder) {
    if (this.scope === ViewportNode.COORDINATE) {
      return builder.getFragCoord();
    }
    return super.generate(builder);
  }
};
ViewportNode.COORDINATE = "coordinate";
ViewportNode.RESOLUTION = "resolution";
ViewportNode.TOP_LEFT = "topLeft";
ViewportNode.BOTTOM_LEFT = "bottomLeft";
ViewportNode.TOP_RIGHT = "topRight";
ViewportNode.BOTTOM_RIGHT = "bottomRight";
var ViewportNode_default = ViewportNode;
var viewportCoordinate = nodeImmutable(ViewportNode, ViewportNode.COORDINATE);
var viewportResolution = nodeImmutable(ViewportNode, ViewportNode.RESOLUTION);
var viewportTopLeft = nodeImmutable(ViewportNode, ViewportNode.TOP_LEFT);
var viewportBottomLeft = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_LEFT);
var viewportTopRight = nodeImmutable(ViewportNode, ViewportNode.TOP_RIGHT);
var viewportBottomRight = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_RIGHT);
addNodeClass(ViewportNode);

// node_modules/three/examples/jsm/nodes/display/ViewportTextureNode.js
var _size = new Vector2();
var ViewportTextureNode = class extends TextureNode_default {
  constructor(uv2 = viewportTopLeft, level = null) {
    super(null, uv2, level);
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
  }
  constructFramebuffer() {
    return new FramebufferTexture();
  }
  construct(builder) {
    if (this.value === null)
      this.value = this.constructFramebuffer(builder);
    return super.construct(builder);
  }
  updateBefore(frame) {
    const renderer = frame.renderer;
    renderer.getDrawingBufferSize(_size);
    const framebufferTexture = this.value;
    if (framebufferTexture.image.width !== _size.width || framebufferTexture.image.height !== _size.height) {
      framebufferTexture.image.width = _size.width;
      framebufferTexture.image.height = _size.height;
      framebufferTexture.needsUpdate = true;
    }
    renderer.copyFramebufferToTexture(framebufferTexture);
  }
};
var ViewportTextureNode_default = ViewportTextureNode;
var viewportTexture = nodeProxy(ViewportTextureNode);
addNodeElement("viewportTexture", viewportTexture);
addNodeClass(ViewportTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportSharedTextureNode.js
var sharedFramebuffer = null;
var ViewportSharedTextureNode = class extends ViewportTextureNode_default {
  constructor(uv2 = viewportTopLeft) {
    super(uv2);
  }
  constructFramebuffer(builder) {
    return sharedFramebuffer || (sharedFramebuffer = super.constructFramebuffer(builder));
  }
};
var ViewportSharedTextureNode_default = ViewportSharedTextureNode;
var viewportSharedTexture = nodeProxy(ViewportSharedTextureNode);
addNodeElement("viewportSharedTexture", viewportSharedTexture);
addNodeClass(ViewportSharedTextureNode);

// node_modules/three/examples/jsm/nodes/code/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", includes3 = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.code = code2;
    this.language = language;
    this._includes = includes3;
  }
  setIncludes(includes3) {
    this._includes = includes3;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes3 = this.getIncludes(builder);
    for (const include of includes3) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
};
var CodeNode_default = CodeNode;
var code = nodeProxy(CodeNode);
var js = (src, includes3) => code(src, includes3, "js");
addNodeClass(CodeNode);

// node_modules/three/examples/jsm/nodes/code/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    if (Array.isArray(parameters)) {
      for (let i = 0; i < parameters.length; i++) {
        const inputNode = inputs[i];
        const node = parameters[i];
        params.push(node.build(builder, inputNode.type));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(node.build(builder, inputNode.type));
        } else {
          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;
var call = (func2, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return nodeObject(new FunctionCallNode(nodeObject(func2), params));
};
addNodeElement("call", call);
addNodeClass(FunctionCallNode);

// node_modules/three/examples/jsm/nodes/code/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "", includes3 = []) {
    super(code2, includes3);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2;
    if (output === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output);
    }
  }
};
var FunctionNode_default = FunctionNode;
var func = (code2, includes3) => nodeObject(new FunctionNode(code2, includes3));
var fn = (code2, includes3) => func(code2, includes3).call;
addNodeClass(FunctionNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableValueNode.js
var ScriptableValueNode = class extends Node_default {
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outpuType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val)
      return;
    if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const value = this.value;
    if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) {
      return value.value;
    }
    return this._cache || value;
  }
  getNodeType(builder) {
    return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
  }
  construct() {
    return this.value && this.value.isNode ? this.value : float();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
};
var ScriptableValueNode_default = ScriptableValueNode;
var scriptableValue = nodeProxy(ScriptableValueNode);
addNodeElement("scriptableValue", scriptableValue);
addNodeClass(ScriptableValueNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableNode.js
var Resources = class extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key))
      return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
};
var Parameters = class {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id2) {
    return this.scriptableNode.getInputLayout(id2);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
};
var global = new Resources();
var ScriptableNode = class extends Node_default {
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue();
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  getLocal(name) {
    return this._local.get(name);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.inputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  getOutputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.outputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  getOutput(name) {
    return this._outputs[name];
  }
  getParameter(name) {
    return this.parameters[name];
  }
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode)
        valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  call(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method(...params);
    }
  }
  async callAsync(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method.constructor.name === "AsyncFunction" ? await method(...params) : method(...params);
    }
  }
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  refresh(output = null) {
    if (output !== null) {
      this.getOutput(output).refresh();
    } else {
      this._refresh();
    }
  }
  getObject() {
    if (this.needsUpdate)
      this.dispose();
    if (this._object !== null)
      return this._object;
    const refresh = () => this.refresh();
    const setOutput = (id2, value) => this.setOutput(id2, value);
    const parameters = new Parameters(this);
    const THREE = global.get("THREE");
    const TSL = global.get("TSL");
    const method = this.getMethod(this.codeNode);
    const params = [parameters, this._local, global, refresh, setOutput, THREE, TSL];
    this._object = method(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element2 of layout.elements) {
          const id2 = element2.id || element2.name;
          if (element2.inputType) {
            if (this.getParameter(id2) === void 0)
              this.setParameter(id2, null);
            this.getParameter(id2).inputType = element2.inputType;
          }
          if (element2.outputType) {
            if (this.getOutput(id2) === void 0)
              this.setOutput(id2, null);
            this.getOutput(id2).outputType = element2.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode)
        valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const output = this.getDefaultOutput().value;
    if (output && output.isNode) {
      return output;
    }
    return float();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate)
      this.dispose();
    if (this._method !== null)
      return this._method;
    const parametersProps = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code2 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code2);
    return this._method;
  }
  dispose() {
    if (this._method === null)
      return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  construct() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(value) {
    if (value === true)
      this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    if (this.codeNode === null)
      return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
};
var ScriptableNode_default = ScriptableNode;
var scriptable = nodeProxy(ScriptableNode);
addNodeElement("scriptable", scriptable);
addNodeClass(ScriptableNode);

// node_modules/three/examples/jsm/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.isFogNode = true;
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  mixAssign(outputNode) {
    return this.mix(outputNode, this.colorNode);
  }
  construct() {
    return this.factorNode;
  }
};
var FogNode_default = FogNode;
var fog = nodeProxy(FogNode);
addNodeElement("fog", fog);
addNodeClass(FogNode);

// node_modules/three/examples/jsm/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.isFogRangeNode = true;
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  construct() {
    return smoothstep(this.nearNode, this.farNode, positionView.z.negate());
  }
};
var FogRangeNode_default = FogRangeNode;
var rangeFog = nodeProxy(FogRangeNode);
addNodeElement("rangeFog", rangeFog);
addNodeClass(FogRangeNode);

// node_modules/three/examples/jsm/nodes/fog/FogExp2Node.js
var FogExp2Node = class extends FogNode_default {
  constructor(colorNode, densityNode) {
    super(colorNode);
    this.isFogExp2Node = true;
    this.densityNode = densityNode;
  }
  construct() {
    const depthNode = positionView.z.negate();
    const densityNode = this.densityNode;
    return densityNode.mul(densityNode, depthNode, depthNode).negate().exp().oneMinus();
  }
};
var FogExp2Node_default = FogExp2Node;
var densityFog = nodeProxy(FogExp2Node);
addNodeElement("densityFog", densityFog);
addNodeClass(FogExp2Node);

// node_modules/three/examples/jsm/nodes/geometry/RangeNode.js
var min2 = null;
var max2 = null;
var RangeNode = class extends Node_default {
  constructor(minNode = float(), maxNode = float()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  getVectorLength(builder) {
    const minLength = builder.getTypeLength(getValueType(this.minNode.value));
    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  getNodeType(builder) {
    return builder.object.isInstancedMesh === true ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
  }
  construct(builder) {
    const object = builder.object;
    let output = null;
    if (object.isInstancedMesh === true) {
      let minValue = this.minNode.value;
      let maxValue = this.maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min2 = min2 || new Vector4();
      max2 = max2 || new Vector4();
      min2.setScalar(0);
      max2.setScalar(0);
      if (minLength === 1)
        min2.setScalar(minValue);
      else if (minValue.isColor)
        min2.set(minValue.r, minValue.g, minValue.b);
      else
        min2.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1)
        max2.setScalar(maxValue);
      else if (maxValue.isColor)
        max2.set(maxValue.r, maxValue.g, maxValue.b);
      else
        max2.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length2 = stride * object.count;
      const array = new Float32Array(length2);
      for (let i = 0; i < length2; i++) {
        const index = i % stride;
        const minElementValue = min2.getComponent(index);
        const maxElementValue = max2.getComponent(index);
        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
      }
      const nodeType = this.getNodeType(builder);
      output = buffer(array, "vec4", object.count).element(instanceIndex).convert(nodeType);
    } else {
      output = float(0);
    }
    return output;
  }
};
var RangeNode_default = RangeNode;
var range = nodeProxy(RangeNode);
addNodeClass(RangeNode);

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.updateType = NodeUpdateType.OBJECT;
    this.updateDispatchCount();
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  onInit() {
  }
  update({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet);
      }
    }
  }
};
var ComputeNode_default = ComputeNode;
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));
addNodeElement("compute", compute);
addNodeClass(ComputeNode);

// node_modules/three/examples/jsm/nodes/lighting/LightNode.js
var LightNode = class extends Node_default {
  constructor(scope = LightNode.TARGET_DIRECTION, light = null) {
    super();
    this.scope = scope;
    this.light = light;
  }
  construct() {
    const { scope, light } = this;
    let output = null;
    if (scope === LightNode.TARGET_DIRECTION) {
      output = cameraViewMatrix.transformDirection(objectPosition(light).sub(objectPosition(light.target)));
    }
    return output;
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
LightNode.TARGET_DIRECTION = "targetDirection";
var LightNode_default = LightNode;
var lightTargetDirection = nodeProxy(LightNode, LightNode.TARGET_DIRECTION);
addNodeClass(LightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightUtils.js
var getDistanceAttenuation = new ShaderNode((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
  return cutoffDistance.greaterThan(0).cond(
    distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
    distanceFalloff
  );
});

// node_modules/three/examples/jsm/nodes/lighting/PointLightNode.js
var PointLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  construct(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation.call({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(lightAttenuation);
    const lightingModelFunctionNode = builder.context.lightingModelNode;
    const reflectedLight = builder.context.reflectedLight;
    if (lightingModelFunctionNode && lightingModelFunctionNode.direct) {
      lightingModelFunctionNode.direct.call({
        lightDirection,
        lightColor,
        reflectedLight
      }, builder);
    }
  }
};
var PointLightNode_default = PointLightNode;
addLightNode(PointLight, PointLightNode);
addNodeClass(PointLightNode);

// node_modules/three/examples/jsm/nodes/lighting/DirectionalLightNode.js
var DirectionalLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  construct(builder) {
    super.construct(builder);
    const lightColor = this.colorNode;
    const lightDirection = lightTargetDirection(this.light);
    const lightingModelFunctionNode = builder.context.lightingModelNode;
    const reflectedLight = builder.context.reflectedLight;
    if (lightingModelFunctionNode && lightingModelFunctionNode.direct) {
      lightingModelFunctionNode.direct.call({
        lightDirection,
        lightColor,
        reflectedLight
      }, builder);
    }
  }
};
var DirectionalLightNode_default = DirectionalLightNode;
addLightNode(DirectionalLight, DirectionalLightNode);
addNodeClass(DirectionalLightNode);

// node_modules/three/examples/jsm/nodes/lighting/SpotLightNode.js
var SpotLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.coneCosNode = uniform(0);
    this.penumbraCosNode = uniform(0);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    super.update(frame);
    const { light } = this;
    this.coneCosNode.value = Math.cos(light.angle);
    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  getSpotAttenuation(angleCosine) {
    const { coneCosNode, penumbraCosNode } = this;
    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
  }
  construct(builder) {
    super.construct(builder);
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const angleCos = lightDirection.dot(lightTargetDirection(light));
    const spotAttenuation = this.getSpotAttenuation(angleCos);
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation.call({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
    const lightingModelFunctionNode = builder.context.lightingModelNode;
    const reflectedLight = builder.context.reflectedLight;
    if (lightingModelFunctionNode && lightingModelFunctionNode.direct) {
      lightingModelFunctionNode.direct.call({
        lightDirection,
        lightColor,
        reflectedLight
      }, builder);
    }
  }
};
var SpotLightNode_default = SpotLightNode;
addLightNode(SpotLight, SpotLightNode);
addNodeClass(SpotLightNode);

// node_modules/three/examples/jsm/lights/IESSpotLight.js
var IESSpotLight = class extends SpotLight {
  constructor(color2, intensity, distance2, angle, penumbra, decay) {
    super(color2, intensity, distance2, angle, penumbra, decay);
    this.iesMap = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.iesMap = source.iesMap;
    return this;
  }
};
var IESSpotLight_default = IESSpotLight;

// node_modules/three/examples/jsm/nodes/lighting/IESSpotLightNode.js
var IESSpotLightNode = class extends SpotLightNode_default {
  getSpotAttenuation(angleCosine) {
    const iesMap = this.light.iesMap;
    let spotAttenuation = null;
    if (iesMap && iesMap.isTexture === true) {
      const angle = angleCosine.acos().mul(1 / Math.PI);
      spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;
    } else {
      spotAttenuation = super.getSpotAttenuation(angleCosine);
    }
    return spotAttenuation;
  }
};
var IESSpotLightNode_default = IESSpotLightNode;
addLightNode(IESSpotLight_default, IESSpotLightNode);
addNodeClass(IESSpotLightNode);

// node_modules/three/examples/jsm/nodes/lighting/AmbientLightNode.js
var AmbientLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  construct({ context: context2 }) {
    context2.irradiance.addAssign(this.colorNode);
  }
};
var AmbientLightNode_default = AmbientLightNode;
addLightNode(AmbientLight, AmbientLightNode);
addNodeClass(AmbientLightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightingContextNode.js
var LightingContextNode = class extends ContextNode_default {
  constructor(node, lightingModelNode = null, backdropNode = null, backdropAlphaNode = null) {
    super(node);
    this.lightingModelNode = lightingModelNode;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
  }
  getNodeType() {
    return "vec3";
  }
  construct(builder) {
    const { lightingModelNode, backdropNode, backdropAlphaNode } = this;
    const context2 = this.context = {};
    const properties = builder.getNodeProperties(this);
    const directDiffuse = temp(vec3()), directSpecular = temp(vec3()), indirectDiffuse = temp(vec3()), indirectSpecular = temp(vec3());
    let totalDiffuse = add(directDiffuse, indirectDiffuse);
    if (backdropNode !== null) {
      totalDiffuse = vec3(backdropAlphaNode !== null ? mix(totalDiffuse, backdropNode, backdropAlphaNode) : backdropNode);
    }
    const totalSpecular = add(directSpecular, indirectSpecular);
    const total = add(totalDiffuse, totalSpecular);
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular,
      total
    };
    const lighting = {
      radiance: temp(vec3()),
      irradiance: temp(vec3()),
      iblIrradiance: temp(vec3()),
      ambientOcclusion: temp(float(1))
    };
    Object.assign(properties, reflectedLight, lighting);
    Object.assign(context2, lighting);
    context2.reflectedLight = reflectedLight;
    context2.lightingModelNode = lightingModelNode || context2.lightingModelNode;
    if (lightingModelNode && lightingModelNode.indirectDiffuse)
      lightingModelNode.indirectDiffuse.call(context2);
    if (lightingModelNode && lightingModelNode.indirectSpecular)
      lightingModelNode.indirectSpecular.call(context2);
    if (lightingModelNode && lightingModelNode.ambientOcclusion)
      lightingModelNode.ambientOcclusion.call(context2);
    return super.construct(builder);
  }
  generate(builder) {
    const { context: context2 } = this;
    const type = this.getNodeType(builder);
    super.generate(builder, type);
    return context2.reflectedLight.total.build(builder, type);
  }
};
var LightingContextNode_default = LightingContextNode;
var lightingContext = nodeProxy(LightingContextNode);
addNodeElement("lightingContext", lightingContext);
addNodeClass(LightingContextNode);

// node_modules/three/examples/jsm/nodes/lighting/HemisphereLightNode.js
var HemisphereLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.lightPositionNode = objectPosition(light);
    this.lightDirectionNode = this.lightPositionNode.normalize();
    this.groundColorNode = uniform(new Color());
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
  }
  generate(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = normalView.dot(lightDirectionNode);
    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.addAssign(irradiance);
  }
};
var HemisphereLightNode_default = HemisphereLightNode;
addLightNode(HemisphereLight, HemisphereLightNode);
addNodeClass(HemisphereLightNode);

// node_modules/three/examples/jsm/nodes/procedural/CheckerNode.js
var checkerShaderNode = new ShaderNode((inputs) => {
  const uv2 = inputs.uv.mul(2);
  const cx = uv2.x.floor();
  const cy = uv2.y.floor();
  const result = cx.add(cy).mod(2);
  return result.sign();
});
var CheckerNode = class extends TempNode_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  generate(builder) {
    return checkerShaderNode.call({ uv: this.uvNode }).build(builder);
  }
};
var CheckerNode_default = CheckerNode;
var checker = nodeProxy(CheckerNode);
addNodeElement("checker", checker);
addNodeClass(CheckerNode);

// node_modules/three/examples/jsm/nodes/loaders/NodeLoader.js
var NodeLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (text) => {
      try {
        onLoad(this.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        this.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parseNodes(json) {
    const nodes = {};
    if (json !== void 0) {
      for (const nodeJSON of json) {
        const { uuid, type } = nodeJSON;
        nodes[uuid] = nodeObject(createNodeFromType(type));
        nodes[uuid].uuid = uuid;
      }
      const meta = { nodes, textures: this.textures };
      for (const nodeJSON of json) {
        nodeJSON.meta = meta;
        const node = nodes[nodeJSON.uuid];
        node.deserialize(nodeJSON);
        delete nodeJSON.meta;
      }
    }
    return nodes;
  }
  parse(json) {
    const node = nodeObject(createNodeFromType(json.type));
    node.uuid = json.uuid;
    const nodes = this.parseNodes(json.nodes);
    const meta = { nodes, textures: this.textures };
    json.meta = meta;
    node.deserialize(json);
    delete json.meta;
    return node;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
};
var NodeLoader_default = NodeLoader;

// node_modules/three/examples/jsm/nodes/materials/LineBasicNodeMaterial.js
var defaultValues = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.setDefaultValues(defaultValues);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var LineBasicNodeMaterial_default = LineBasicNodeMaterial;
addNodeMaterial(LineBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshNormalNodeMaterial.js
var defaultValues2 = new MeshNormalMaterial();
var MeshNormalNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshNormalNodeMaterial = true;
    this.setDefaultValues(defaultValues2);
    this.setValues(parameters);
  }
  constructDiffuseColor({ stack: stack2 }) {
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    stack2.assign(diffuseColor, vec4(directionToColor(transformedNormalView), opacityNode));
  }
  copy(source) {
    this.opacityNode = source.opacityNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var MeshNormalNodeMaterial_default = MeshNormalNodeMaterial;
addNodeMaterial(MeshNormalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues3 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = false;
    this.setDefaultValues(defaultValues3);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var MeshBasicNodeMaterial_default = MeshBasicNodeMaterial;
addNodeMaterial(MeshBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js
var BRDF_Lambert = new ShaderNode((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
var BRDF_Lambert_default = BRDF_Lambert;

// node_modules/three/examples/jsm/nodes/functions/BSDF/F_Schlick.js
var F_Schlick = new ShaderNode((inputs) => {
  const { f0, f90, dotVH } = inputs;
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
var F_Schlick_default = F_Schlick;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_BlinnPhong.js
var G_BlinnPhong_Implicit = () => float(0.25);
var D_BlinnPhong = new ShaderNode(({ dotNH }) => {
  return shininess.mul(0.5 / Math.PI).add(1).mul(dotNH.pow(shininess));
});
var BRDF_BlinnPhong = new ShaderNode(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F = F_Schlick_default.call({ f0: specularColor, f90: 1, dotVH });
  const G = G_BlinnPhong_Implicit();
  const D = D_BlinnPhong.call({ dotNH });
  return F.mul(G).mul(D);
});
var BRDF_BlinnPhong_default = BRDF_BlinnPhong;

// node_modules/three/examples/jsm/nodes/functions/PhongLightingModel.js
var RE_Direct_BlinnPhong = new ShaderNode(({ lightDirection, lightColor, reflectedLight }) => {
  const dotNL = transformedNormalView.dot(lightDirection).clamp();
  const irradiance = dotNL.mul(lightColor);
  reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default.call({ diffuseColor: diffuseColor.rgb })));
  reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong_default.call({ lightDirection })).mul(materialReflectivity));
});
var RE_IndirectDiffuse_BlinnPhong = new ShaderNode(({ irradiance, reflectedLight }) => {
  reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default.call({ diffuseColor })));
});
var phongLightingModel = lightingModel(RE_Direct_BlinnPhong, RE_IndirectDiffuse_BlinnPhong);
var PhongLightingModel_default = phongLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshPhongNodeMaterial.js
var defaultValues4 = new MeshPhongMaterial();
var MeshPhongNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhongNodeMaterial = true;
    this.lights = true;
    this.shininessNode = null;
    this.specularNode = null;
    this.setDefaultValues(defaultValues4);
    this.setValues(parameters);
  }
  constructLightingModel() {
    return PhongLightingModel_default;
  }
  constructVariants({ stack: stack2 }) {
    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4);
    stack2.assign(shininess, shininessNode);
    const specularNode = this.specularNode || materialSpecularColor;
    stack2.assign(specularColor, specularNode);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.shininessNode = source.shininessNode;
    this.specularNode = source.specularNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var MeshPhongNodeMaterial_default = MeshPhongNodeMaterial;
addNodeMaterial(MeshPhongNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/material/getGeometryRoughness.js
var getGeometryRoughness = new ShaderNode(() => {
  const dxy = normalGeometry.dFdx().abs().max(normalGeometry.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
var getGeometryRoughness_default = getGeometryRoughness;

// node_modules/three/examples/jsm/nodes/functions/material/getRoughness.js
var getRoughness = new ShaderNode((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness_default.call();
  let roughnessFactor = roughness2.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
var getRoughness_default = getRoughness;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js
var V_GGX_SmithCorrelated = new ShaderNode((inputs) => {
  const { alpha, dotNL, dotNV } = inputs;
  const a2 = alpha.pow2();
  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
  return div(0.5, gv.add(gl).max(EPSILON));
});
var V_GGX_SmithCorrelated_default = V_GGX_SmithCorrelated;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX.js
var D_GGX = new ShaderNode((inputs) => {
  const { alpha, dotNH } = inputs;
  const a2 = alpha.pow2();
  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
  return a2.div(denom.pow2()).mul(1 / Math.PI);
});
var D_GGX_default = D_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js
var BRDF_GGX = new ShaderNode((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2 } = inputs;
  const alpha = roughness2.pow2();
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = transformedNormalView.dot(lightDirection).clamp();
  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F = F_Schlick_default.call({ f0, f90, dotVH });
  const V = V_GGX_SmithCorrelated_default.call({ alpha, dotNL, dotNV });
  const D = D_GGX_default.call({ alpha, dotNH });
  return F.mul(V).mul(D);
});
var BRDF_GGX_default = BRDF_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/DFGApprox.js
var DFGApprox = new ShaderNode((inputs) => {
  const { roughness: roughness2 } = inputs;
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r = roughness2.mul(c0).add(c1);
  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
  return fab;
});
var DFGApprox_default = DFGApprox;

// node_modules/three/examples/jsm/nodes/functions/PhysicalLightingModel.js
var computeMultiscattering = (singleScatter, multiScatter, specularF90 = float(1)) => {
  const fab = DFGApprox_default.call({ roughness });
  const FssEss = specularColor.mul(fab.x).add(specularF90.mul(fab.y));
  const Ess = fab.x.add(fab.y);
  const Ems = Ess.oneMinus();
  const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619));
  const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
  singleScatter.addAssign(FssEss);
  multiScatter.addAssign(Fms.mul(Ems));
};
var RE_IndirectSpecular_Physical = new ShaderNode((inputs) => {
  const { radiance, iblIrradiance, reflectedLight } = inputs;
  const singleScattering = temp(vec3());
  const multiScattering = temp(vec3());
  const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
  computeMultiscattering(singleScattering, multiScattering);
  const totalScattering = singleScattering.add(multiScattering);
  const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());
  reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
  reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));
  reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));
});
var RE_IndirectDiffuse_Physical = new ShaderNode((inputs) => {
  const { irradiance, reflectedLight } = inputs;
  reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default.call({ diffuseColor })));
});
var RE_Direct_Physical = new ShaderNode((inputs) => {
  const { lightDirection, lightColor, reflectedLight } = inputs;
  const dotNL = transformedNormalView.dot(lightDirection).clamp();
  const irradiance = dotNL.mul(lightColor);
  reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default.call({ diffuseColor: diffuseColor.rgb })));
  reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX_default.call({ lightDirection, f0: specularColor, f90: 1, roughness })));
});
var RE_AmbientOcclusion_Physical = new ShaderNode(({ ambientOcclusion, reflectedLight }) => {
  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
  const aoNV = dotNV.add(ambientOcclusion);
  const aoExp = roughness.mul(-16).oneMinus().negate().exp2();
  const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
  reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
  reflectedLight.indirectSpecular.mulAssign(aoNode);
});
var physicalLightingModel = lightingModel(RE_Direct_Physical, RE_IndirectDiffuse_Physical, RE_IndirectSpecular_Physical, RE_AmbientOcclusion_Physical);
var PhysicalLightingModel_default = physicalLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues5 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.setDefaultValues(defaultValues5);
    this.setValues(parameters);
  }
  constructLightingModel() {
    return PhysicalLightingModel_default;
  }
  constructVariants({ stack: stack2 }) {
    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
    stack2.assign(metalness, metalnessNode);
    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
    roughnessNode = getRoughness_default.call({ roughness: roughnessNode });
    stack2.assign(roughness, roughnessNode);
    const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalnessNode);
    stack2.assign(specularColor, specularColorNode);
    stack2.assign(diffuseColor, vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.normalNode = source.normalNode;
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    this.envNode = source.envNode;
    this.lightsNode = source.lightsNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var MeshStandardNodeMaterial_default = MeshStandardNodeMaterial;
addNodeMaterial(MeshStandardNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshPhysicalNodeMaterial.js
var defaultValues6 = new MeshPhysicalMaterial();
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.iridescenceNode = null;
    this.iridescenceIORNode = null;
    this.iridescenceThicknessNode = null;
    this.specularIntensityNode = null;
    this.specularColorNode = null;
    this.transmissionNode = null;
    this.thicknessNode = null;
    this.attenuationDistanceNode = null;
    this.attenuationColorNode = null;
    this.setDefaultValues(defaultValues6);
    this.setValues(parameters);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    this.iridescenceNode = source.iridescenceNode;
    this.iridescenceIORNode = source.iridescenceIORNode;
    this.iridescenceThicknessNode = source.iridescenceThicknessNode;
    this.specularIntensityNode = source.specularIntensityNode;
    this.specularColorNode = source.specularColorNode;
    this.transmissionNode = source.transmissionNode;
    this.thicknessNode = source.thicknessNode;
    this.attenuationDistanceNode = source.attenuationDistanceNode;
    this.attenuationColorNode = source.attenuationColorNode;
    return super.copy(source);
  }
};
var MeshPhysicalNodeMaterial_default = MeshPhysicalNodeMaterial;
addNodeMaterial(MeshPhysicalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/PointsNodeMaterial.js
var defaultValues7 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isPointsNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.transparent = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.sizeNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues7);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.sizeNode = source.sizeNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var PointsNodeMaterial_default = PointsNodeMaterial;
addNodeMaterial(PointsNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/SpriteNodeMaterial.js
var defaultValues8 = new SpriteMaterial();
var SpriteNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.setDefaultValues(defaultValues8);
    this.setValues(parameters);
  }
  constructPosition({ object, context: context2 }) {
    const { positionNode, rotationNode, scaleNode } = this;
    const vertex = positionLocal;
    let mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
    let scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());
    if (scaleNode !== null) {
      scale = scale.mul(scaleNode);
    }
    let alignedPosition = vertex.xy;
    if (object.center && object.center.isVector2 === true) {
      alignedPosition = alignedPosition.sub(uniform(object.center).sub(0.5));
    }
    alignedPosition = alignedPosition.mul(scale);
    const rotation = rotationNode || materialRotation;
    const cosAngle = rotation.cos();
    const sinAngle = rotation.sin();
    const rotatedPosition = vec2(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( alignedPosition )?
      vec2(cosAngle, sinAngle.negate()).dot(alignedPosition),
      vec2(sinAngle, cosAngle).dot(alignedPosition)
    );
    mvPosition = vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
    const modelViewProjection2 = cameraProjectionMatrix.mul(mvPosition);
    context2.vertex = vertex;
    return modelViewProjection2;
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
};
var SpriteNodeMaterial_default = SpriteNodeMaterial;
addNodeMaterial(SpriteNodeMaterial);

// node_modules/three/examples/jsm/nodes/loaders/NodeMaterialLoader.js
var superFromTypeFunction = MaterialLoader.createMaterialFromType;
MaterialLoader.createMaterialFromType = function(type) {
  const material = createNodeMaterialFromType(type);
  if (material !== void 0) {
    return material;
  }
  return superFromTypeFunction.call(this, type);
};
var NodeMaterialLoader = class extends MaterialLoader {
  constructor(manager) {
    super(manager);
    this.nodes = {};
  }
  parse(json) {
    const material = super.parse(json);
    const nodes = this.nodes;
    const inputNodes = json.inputNodes;
    for (const property2 in inputNodes) {
      const uuid = inputNodes[property2];
      material[property2] = nodes[uuid];
    }
    return material;
  }
  setNodes(value) {
    this.nodes = value;
    return this;
  }
};
var NodeMaterialLoader_default = NodeMaterialLoader;

// node_modules/three/examples/jsm/nodes/loaders/NodeObjectLoader.js
var NodeObjectLoader = class extends ObjectLoader {
  constructor(manager) {
    super(manager);
    this._nodesJSON = null;
  }
  parse(json, onLoad) {
    this._nodesJSON = json.nodes;
    const data = super.parse(json, onLoad);
    this._nodesJSON = null;
    return data;
  }
  parseNodes(json, textures) {
    if (json !== void 0) {
      const loader = new NodeLoader_default();
      loader.setTextures(textures);
      return loader.parseNodes(json);
    }
    return {};
  }
  parseMaterials(json, textures) {
    const materials = {};
    if (json !== void 0) {
      const nodes = this.parseNodes(this._nodesJSON, textures);
      const loader = new NodeMaterialLoader_default();
      loader.setTextures(textures);
      loader.setNodes(nodes);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        materials[data.uuid] = loader.parse(data);
      }
    }
    return materials;
  }
};
var NodeObjectLoader_default = NodeObjectLoader;

// node_modules/three/examples/jsm/nodes/core/NodeParser.js
var NodeParser = class {
  parseFunction() {
    console.warn("Abstract function.");
  }
};
var NodeParser_default = NodeParser;

// node_modules/three/examples/jsm/nodes/core/NodeFunction.js
var NodeFunction = class {
  constructor(type, inputs, name = "", presicion = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.presicion = presicion;
  }
  getCode() {
    console.warn("Abstract function.");
  }
};
NodeFunction.isNodeFunction = true;
var NodeFunction_default = NodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeFunction.js
var declarationRegexp = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
var propertiesRegexp = /[a-z_0-9]+/ig;
var pragmaMain = "#pragma main";
var parse = (source) => {
  source = source.trim();
  const pragmaMainIndex = source.indexOf(pragmaMain);
  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
  const declaration = mainCode.match(declarationRegexp);
  if (declaration !== null && declaration.length === 5) {
    const inputsCode = declaration[4];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const isConst = propsMatches[i][0] === "const";
      if (isConst === true) {
        i++;
      }
      let qualifier = propsMatches[i][0];
      if (qualifier === "in" || qualifier === "out" || qualifier === "inout") {
        i++;
      } else {
        qualifier = "";
      }
      const type2 = propsMatches[i++][0];
      let count = Number.parseInt(propsMatches[i][0]);
      if (Number.isNaN(count) === false)
        i++;
      else
        count = null;
      const name2 = propsMatches[i++][0];
      inputs.push(new NodeFunctionInput_default(type2, name2, count, qualifier, isConst));
    }
    const blockCode = mainCode.substring(declaration[0].length);
    const name = declaration[3] !== void 0 ? declaration[3] : "";
    const type = declaration[2];
    const presicion = declaration[1] !== void 0 ? declaration[1] : "";
    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
    return {
      type,
      inputs,
      name,
      presicion,
      inputsCode,
      blockCode,
      headerCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a GLSL code.");
  }
};
var GLSLNodeFunction = class extends NodeFunction_default {
  constructor(source) {
    const { type, inputs, name, presicion, inputsCode, blockCode, headerCode } = parse(source);
    super(type, inputs, name, presicion);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.headerCode = headerCode;
  }
  getCode(name = this.name) {
    let code2;
    const blockCode = this.blockCode;
    if (blockCode !== "") {
      const { type, inputsCode, headerCode, presicion } = this;
      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
      if (presicion !== "") {
        declarationCode = `${presicion} ${declarationCode}`;
      }
      code2 = headerCode + declarationCode + blockCode;
    } else {
      code2 = "";
    }
    return code2;
  }
};
var GLSLNodeFunction_default = GLSLNodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeParser.js
var GLSLNodeParser = class extends NodeParser_default {
  parseFunction(source) {
    return new GLSLNodeFunction_default(source);
  }
};
var GLSLNodeParser_default = GLSLNodeParser;

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_noise.js
var mx_noise = code(`float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}`);
var includes = [mx_noise];
var mx_perlin_noise_float = fn("float mx_perlin_noise_float( any p )", includes);
var mx_perlin_noise_vec2 = fn("vec2 mx_perlin_noise_vec2( any p )", includes);
var mx_perlin_noise_vec3 = fn("vec3 mx_perlin_noise_vec3( any p )", includes);
var mx_cell_noise_float = fn("float mx_cell_noise_float( vec3 p )", includes);
var mx_worley_noise_float = fn("float mx_worley_noise_float( any p, float jitter, int metric )", includes);
var mx_worley_noise_vec2 = fn("float mx_worley_noise_vec2( any p, float jitter, int metric )", includes);
var mx_worley_noise_vec3 = fn("float mx_worley_noise_vec3( any p, float jitter, int metric )", includes);
var mx_fractal_noise_float = fn("float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec2 = fn("float mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec3 = fn("float mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec4 = fn("float mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )", includes);

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_hsv.js
var mx_hsvtorgb = fn(`vec3 mx_hsvtorgb(vec3 hsv)
{
    // Reference for this technique: Foley & van Dam
    float h = hsv.x; float s = hsv.y; float v = hsv.z;
    if (s < 0.0001f) {
      return vec3 (v, v, v);
    } else {
        h = 6.0f * (h - floor(h));  // expand to [0..6)
        int hi = int(trunc(h));
        float f = h - float(hi);
        float p = v * (1.0f-s);
        float q = v * (1.0f-s*f);
        float t = v * (1.0f-s*(1.0f-f));
        if (hi == 0)
            return vec3 (v, t, p);
        else if (hi == 1)
            return vec3 (q, v, p);
        else if (hi == 2)
            return vec3 (p, v, t);
        else if (hi == 3)
            return vec3 (p, q, v);
        else if (hi == 4)
            return vec3 (t, p, v);
        return vec3 (v, p, q);
    }
}`);
var mx_rgbtohsv = fn(`vec3 mx_rgbtohsv(vec3 c)
{
    // See Foley & van Dam
    float r = c.x; float g = c.y; float b = c.z;
    float mincomp = min (r, min(g, b));
    float maxcomp = max (r, max(g, b));
    float delta = maxcomp - mincomp;  // chroma
    float h, s, v;
    v = maxcomp;
    if (maxcomp > 0.0f)
        s = delta / maxcomp;
    else s = 0.0f;
    if (s <= 0.0f)
        h = 0.0f;
    else {
        if      (r >= maxcomp) h = (g-b) / delta;
        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
        else                   h = 4.0f + (r-g) / delta;
        h *= (1.0f/6.0f);
        if (h < 0.0f)
            h += 1.0f;
    }
    return vec3(h, s, v);
}`);

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_transform_color.js
var mx_transform_color = code(`#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    bvec3 isAbove = greaterThan(color, vec3(0.04045));
    vec3 linSeg = color / 12.92;
    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
    return mix(linSeg, powSeg, isAbove);
}`);
var includes2 = [mx_transform_color];
var mx_srgb_texture_to_lin_rec709 = fn("vec3 mx_srgb_texture_to_lin_rec709( vec3 color )", includes2);

// node_modules/three/examples/jsm/nodes/materialx/MaterialXNodes.js
var mx_aastep = (threshold, value) => {
  threshold = float(threshold);
  value = float(value);
  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.7071067811865476);
  return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);
};
var _ramp = (a, b, uv2, p) => mix(a, b, uv2[p].clamp());
var mx_ramplr = (valuel, valuer, texcoord = uv()) => _ramp(valuel, valuer, texcoord, "x");
var mx_ramptb = (valuet, valueb, texcoord = uv()) => _ramp(valuet, valueb, texcoord, "y");
var _split = (a, b, center, uv2, p) => mix(a, b, mx_aastep(center, uv2[p]));
var mx_splitlr = (valuel, valuer, center, texcoord = uv()) => _split(valuel, valuer, center, texcoord, "x");
var mx_splittb = (valuet, valueb, center, texcoord = uv()) => _split(valuet, valueb, center, texcoord, "y");
var mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv()) => uv_geo.mul(uv_scale).add(uv_offset);
var mx_safepower = (in1, in2 = 1) => {
  in1 = float(in1);
  return in1.abs().pow(in2).mul(in1.sign());
};
var mx_contrast = (input, amount = 1, pivot = 0.5) => float(input).sub(pivot).mul(amount).add(pivot);
var mx_noise_float = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec2 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec2(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec3 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec4 = (texcoord = uv(), amplitude = 1, pivot = 0) => {
  texcoord = texcoord.convert("vec2|vec3");
  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));
  return noise_vec4.mul(amplitude).add(pivot);
};
var mx_worley_noise_float2 = (texcoord = uv(), jitter = 1) => mx_worley_noise_float(texcoord.convert("vec2|vec3"), jitter, 1);
var mx_worley_noise_vec22 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec2(texcoord.convert("vec2|vec3"), jitter, 1);
var mx_worley_noise_vec32 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec3(texcoord.convert("vec2|vec3"), jitter, 1);
var mx_cell_noise_float2 = (texcoord = uv()) => mx_cell_noise_float(texcoord.convert("vec2|vec3"));
var mx_fractal_noise_float2 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_float(position, octaves, lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec22 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec2(position, octaves, lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec32 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec3(position, octaves, lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec42 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec4(position, octaves, lacunarity, diminish).mul(amplitude);
export {
  AONode_default as AONode,
  AmbientLightNode_default as AmbientLightNode,
  AnalyticLightNode_default as AnalyticLightNode,
  ArrayElementNode_default as ArrayElementNode,
  ArrayUniformNode_default as ArrayUniformNode,
  AttributeNode_default as AttributeNode,
  BRDF_BlinnPhong_default as BRDF_BlinnPhong,
  BRDF_GGX_default as BRDF_GGX,
  BRDF_Lambert_default as BRDF_Lambert,
  BitangentNode_default as BitangentNode,
  BlendModeNode_default as BlendModeNode,
  BufferAttributeNode_default as BufferAttributeNode,
  BufferNode_default as BufferNode,
  BypassNode_default as BypassNode,
  CacheNode_default as CacheNode,
  CameraNode_default as CameraNode,
  CheckerNode_default as CheckerNode,
  CodeNode_default as CodeNode,
  ColorAdjustmentNode_default as ColorAdjustmentNode,
  ColorSpaceNode_default as ColorSpaceNode,
  ComputeNode_default as ComputeNode,
  CondNode_default as CondNode,
  ConstNode_default as ConstNode,
  ContextNode_default as ContextNode,
  ConvertNode_default as ConvertNode,
  CubeTextureNode_default as CubeTextureNode,
  DFGApprox_default as DFGApprox,
  D_GGX_default as D_GGX,
  DirectionalLightNode_default as DirectionalLightNode,
  DiscardNode_default as DiscardNode,
  EPSILON,
  EnvironmentNode_default as EnvironmentNode,
  EquirectUVNode_default as EquirectUVNode,
  ExpressionNode_default as ExpressionNode,
  ExtendedMaterialNode_default as ExtendedMaterialNode,
  F_Schlick_default as F_Schlick,
  FogExp2Node_default as FogExp2Node,
  FogNode_default as FogNode,
  FogRangeNode_default as FogRangeNode,
  FrontFacingNode_default as FrontFacingNode,
  FunctionCallNode_default as FunctionCallNode,
  FunctionNode_default as FunctionNode,
  GLSLNodeParser_default as GLSLNodeParser,
  HemisphereLightNode_default as HemisphereLightNode,
  IESSpotLightNode_default as IESSpotLightNode,
  INFINITY,
  InstanceIndexNode_default as InstanceIndexNode,
  InstanceNode_default as InstanceNode,
  JoinNode_default as JoinNode,
  LightNode_default as LightNode,
  LightingContextNode_default as LightingContextNode,
  LightingModel_default as LightingModel,
  LightingNode_default as LightingNode,
  LightsNode_default as LightsNode,
  LineBasicNodeMaterial_default as LineBasicNodeMaterial,
  LoopNode_default as LoopNode,
  MatcapUVNode_default as MatcapUVNode,
  MaterialNode_default as MaterialNode,
  MaterialReferenceNode_default as MaterialReferenceNode,
  MathNode_default as MathNode,
  MaxMipLevelNode_default as MaxMipLevelNode,
  MeshBasicNodeMaterial_default as MeshBasicNodeMaterial,
  MeshNormalNodeMaterial_default as MeshNormalNodeMaterial,
  MeshPhongNodeMaterial_default as MeshPhongNodeMaterial,
  MeshPhysicalNodeMaterial_default as MeshPhysicalNodeMaterial,
  MeshStandardNodeMaterial_default as MeshStandardNodeMaterial,
  ModelNode_default as ModelNode,
  ModelViewProjectionNode_default as ModelViewProjectionNode,
  Node_default as Node,
  NodeAttribute_default as NodeAttribute,
  NodeBuilder_default as NodeBuilder,
  NodeCache_default as NodeCache,
  NodeCode_default as NodeCode,
  NodeFrame_default as NodeFrame,
  NodeFunctionInput_default as NodeFunctionInput,
  NodeKeywords_default as NodeKeywords,
  NodeLoader_default as NodeLoader,
  NodeMaterial_default as NodeMaterial,
  NodeMaterialLoader_default as NodeMaterialLoader,
  NodeObjectLoader_default as NodeObjectLoader,
  NodeShaderStage,
  NodeType,
  NodeUniform_default as NodeUniform,
  NodeUpdateType,
  NodeUtils_exports as NodeUtils,
  NodeVar_default as NodeVar,
  NodeVarying_default as NodeVarying,
  NormalMapNode_default as NormalMapNode,
  NormalNode_default as NormalNode,
  Object3DNode_default as Object3DNode,
  OperatorNode_default as OperatorNode,
  OscNode_default as OscNode,
  PackingNode_default as PackingNode,
  PointLightNode_default as PointLightNode,
  PointUVNode_default as PointUVNode,
  PointsNodeMaterial_default as PointsNodeMaterial,
  PositionNode_default as PositionNode,
  PosterizeNode_default as PosterizeNode,
  PropertyNode_default as PropertyNode,
  RangeNode_default as RangeNode,
  ReferenceNode_default as ReferenceNode,
  ReflectVectorNode_default as ReflectVectorNode,
  RemapNode_default as RemapNode,
  RotateUVNode_default as RotateUVNode,
  ScriptableNode_default as ScriptableNode,
  ScriptableValueNode_default as ScriptableValueNode,
  ShaderNode,
  SkinningNode_default as SkinningNode,
  SpecularMIPLevelNode_default as SpecularMIPLevelNode,
  SplitNode_default as SplitNode,
  SpotLightNode_default as SpotLightNode,
  SpriteNodeMaterial_default as SpriteNodeMaterial,
  SpriteSheetUVNode_default as SpriteSheetUVNode,
  StackNode_default as StackNode,
  StorageBufferNode_default as StorageBufferNode,
  TBNViewMatrix,
  TangentNode_default as TangentNode,
  TempNode_default as TempNode,
  TextureNode_default as TextureNode,
  TimerNode_default as TimerNode,
  ToneMappingNode_default as ToneMappingNode,
  TriplanarTexturesNode_default as TriplanarTexturesNode,
  UVNode_default as UVNode,
  UniformNode_default as UniformNode,
  UserDataNode_default as UserDataNode,
  V_GGX_SmithCorrelated_default as V_GGX_SmithCorrelated,
  VarNode_default as VarNode,
  VaryingNode_default as VaryingNode,
  ViewportNode_default as ViewportNode,
  ViewportSharedTextureNode_default as ViewportSharedTextureNode,
  ViewportTextureNode_default as ViewportTextureNode,
  abs,
  acos,
  add,
  addLightNode,
  addNodeClass,
  addNodeElement,
  addNodeMaterial,
  and,
  arrayBuffer,
  asin,
  assign,
  atan,
  atan2,
  attribute,
  bitAnd,
  bitOr,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bmat3,
  bmat4,
  bool,
  buffer,
  bufferAttribute,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraWorldMatrix,
  ceil,
  checker,
  clamp,
  code,
  color,
  colorSpace,
  colorToDirection,
  compute,
  cond,
  context,
  convert,
  cos,
  createNodeFromType,
  createNodeMaterialFromType,
  cross,
  cubeTexture,
  dFdx,
  dFdy,
  defaultBuildStages,
  defaultShaderStages,
  degrees,
  densityFog,
  difference,
  diffuseColor,
  directionToColor,
  discard,
  distance,
  div,
  dodge,
  dot,
  dynamicBufferAttribute,
  element,
  equal,
  equirectUV,
  exp,
  exp2,
  expression,
  faceDirection,
  faceForward,
  float,
  floor,
  fn,
  fog,
  fract,
  frameId,
  frontFacing,
  func,
  getConstNodeType,
  getDistanceAttenuation,
  getGeometryRoughness_default as getGeometryRoughness,
  getRoughness_default as getRoughness,
  global,
  greaterThan,
  greaterThanEqual,
  hue,
  imat3,
  imat4,
  instance,
  instanceIndex,
  int,
  inverseSqrt,
  ivec2,
  ivec3,
  ivec4,
  js,
  label,
  length,
  lessThan,
  lessThanEqual,
  lightTargetDirection,
  lightingContext,
  lightingModel,
  lights,
  lightsWithoutWrap,
  log,
  log2,
  loop,
  lumaCoeffs,
  luminance,
  mat3,
  mat4,
  matcapUV,
  materialAlphaTest,
  materialColor,
  materialEmissive,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialReference,
  materialReflectivity,
  materialRotation,
  materialRoughness,
  materialShininess,
  materialSpecularColor,
  materialUV,
  max,
  maxMipLevel,
  metalness,
  min,
  mix,
  mod,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  mul,
  mx_aastep,
  mx_cell_noise_float2 as mx_cell_noise_float,
  mx_contrast,
  mx_fractal_noise_float2 as mx_fractal_noise_float,
  mx_fractal_noise_vec22 as mx_fractal_noise_vec2,
  mx_fractal_noise_vec32 as mx_fractal_noise_vec3,
  mx_fractal_noise_vec42 as mx_fractal_noise_vec4,
  mx_hsvtorgb,
  mx_noise_float,
  mx_noise_vec2,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_safepower,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_transform_uv,
  mx_worley_noise_float2 as mx_worley_noise_float,
  mx_worley_noise_vec22 as mx_worley_noise_vec2,
  mx_worley_noise_vec32 as mx_worley_noise_vec3,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalWorld,
  normalize,
  objectDirection,
  objectNormalMatrix,
  objectPosition,
  objectViewMatrix,
  objectViewPosition,
  objectWorldMatrix,
  oneMinus,
  or,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  overlay,
  PhongLightingModel_default as phongLightingModel,
  PhysicalLightingModel_default as physicalLightingModel,
  pointUV,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  range,
  rangeFog,
  reciprocal,
  reference,
  reflect,
  reflectVector,
  refract,
  remainder,
  remap,
  remapClamp,
  rotateUV,
  roughness,
  round,
  sampler,
  saturate,
  saturation,
  screen,
  scriptable,
  scriptableValue,
  shader,
  shaderStages,
  shiftLeft,
  shiftRight,
  shininess,
  sign,
  sin,
  skinning,
  smoothstep,
  specularColor,
  specularMIPLevel,
  split,
  spritesheetUV,
  sqrt,
  stack,
  step,
  storage,
  string,
  sub,
  tan,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  temp,
  texture,
  timerDelta,
  timerGlobal,
  timerLocal,
  toneMapping,
  transformDirection,
  transformedBitangentView,
  transformedBitangentWorld,
  transformedNormalView,
  transformedNormalWorld,
  transformedTangentView,
  transformedTangentWorld,
  triplanarTexture,
  triplanarTextures,
  uint,
  umat3,
  umat4,
  uniform,
  userData,
  uv,
  uvec2,
  uvec3,
  uvec4,
  varying,
  vec2,
  vec3,
  vec4,
  vectorComponents,
  vibrance,
  viewportBottomLeft,
  viewportBottomRight,
  viewportCoordinate,
  viewportResolution,
  viewportSharedTexture,
  viewportTexture,
  viewportTopLeft,
  viewportTopRight,
  xor
};
//# sourceMappingURL=three_examples_jsm_nodes_Nodes__js.js.map
